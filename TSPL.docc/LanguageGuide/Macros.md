# Macros

Transform code at compile time to generate repetitive code.

Macros transform your source code when you compile it,
letting you avoid writing out repetitive code by hand
and omit boilerplate code.
For code that uses macros,
Swift expands each macro as the first step in building that code.

![](macro-expansion)

Expanding a macro is always an additive operation:
Macros add new code,
but they never delete code
or modify code that you wrote by hand.

Both the input to a macro and the output of macro expansion
are checked to ensure they're syntactically valid Swift code.
Likewise, the values you pass to a macro
and the values in code generated by a macro
are checked to ensure they have the correct types.

Swift has two kinds of macros.
*Attached macros* modify the declaration that they're attached to.
*Freestanding macros* appear on their own,
without being attached to a declaration.

## Freestanding Macros

To call a freestanding macro,
you write a number sign (`#`) before its name,
followed by any arguments to the macro in parentheses.
For example:

```swift
let currentLine = #line
#warning("Something's wrong")
```

In the first line,
`#line` is a call to the `line` macro from the Swift standard library.
When you compile this code,
Swift calls that macro's implementation,
which replaces `#line` with the current line number.
In the second line,
`#warning` calls another macro from the standard library
to produce a custom warning when the code is compiled.

Freestanding macros can produce a value, like `#line`,
or they can perform an action at compile time, like `#warning`.
<!-- SE-0397: or they can generate new declarations.  -->

## Attached Macros

To call an attached macro,
you write an at sign (`@`) before its name,
followed by any arguments to the macro in parentheses.

Attached macros modify the declaration that they're attached to.
They add code to that declaration,
like defining a new method or adding conformance to a protocol.

<!-- XXX Frame differently; this is motivation, not an example -->
For example, consider the following code
that doesn't use macros:

```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

In this code,
each of the options in the `SundaeToppings` option set
includes a call to the initializer,
which is repetitive and manual.
It would be easy to make a mistake when adding a new option,
like typing the wrong number at the end of the line.

Here's a version of this code that uses a macro instead:

```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

This version of `SundaeToppings`
calls the `@OptionSet` macro from the Swift standard library.
The macro reads the list of cases in the private enumeration,
generates the list of constants for each option,
and adds a conformance to the `OptionSet` protocol.

<!-- XXX link above to both the macro and the protocol -->
[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset

For comparison,
after the compiler expands the `@OptionSet` macro,
here's what the source code looks like:

```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}
extension SundaeToppings: OptionSet  {}
```

All of the code after the private enumeration
comes from the `@OptionSet` macro.
The version of `SundaeToppings`
that uses a macro to generate all of the static variables
is easier to read and easier to maintain
than the manual version at the start of this section.

## Macro Declarations

In most Swift code,
you implement a symbol, like a function or type,
and there's no separate declaration.
However, for macros, the declaration and implementation are separate.
A macro's implementation contains the code
that expands the macro by generating Swift code,
and its declaration 
as well as the macro's name, what parameters it takes,
where it can be used,
and what kind of code it generates.
<!-- XXX typically (always?) in different libraries -->

You introduce a macro declaration with the `macro` keyword.
For example,
here's part of the declaration for
the `@OptionSet` macro used in the previous example:

```swift
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The first line
specifies the macro's name, `OptionSet`,
and the arguments that takes, in this case none.
The second line
uses the `#externalMacro(module:type:)` macro from the standard library
to tell Swift where the macro's implementation is.
In this case,
the `SwiftMacros` module
contains a type named `OptionSetMacro`,
which implements the `@OptionSet` macro.

<!-- XXX TR:
Is there any other syntax besides #externalMacro
that's common enough to call out in the guide,
versus just being covered in the reference?
-->

> Note:
> Macros are always declared as `public`.
> Because the code that declares a macro
> is in a different module from code that uses that macro,
> there isn't anywhere you could apply a non-public macro.

A macro declaration also includes information
about where that macro can be used.
Here's a partial declaration of `@OptionSet`,
with those attributes added:

```swift
@attached(member)
@attached(conformance)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The `@attached` attribute on this macro declaration
indicates that the `@OptionSet` macro is an attached macro.
That attribute appears twice in this declaration,
once for each macro role that `@OptionSet` has.
For a freestanding macro, you write `@freestanding` instead.

```
@freestanding(expression)
public macro line<T: ExpressibleByIntegerLiteral>() -> T =
        /* ... location of the macro implementation... */
```

A *macro role* indicates where the code that the macro generate goes.
Every macro has one or more roles,
which you write as part of the attributes
at the beginning of the macro declaration.

For example,
the `#line` macro above has the `expression` role,
and the `@OptionSet` macro above has two roles --- `conformance` and `member`.
An expression macro produces a value or performs an action.
A conformance macro adds one or more protocol conformances.
The `@OptionSet` macro
extends the type that you apply the macro to,
to add conformance to the `OptionSet` protocol.
A member macro adds new members to the type you apply the macro to.
In this case,
the `@OptionSet` macro adds an `init(rawValue:)` initializer
that's required by the `OptionSet` protocol,
as well as some additional members.

In addition to the macro's role,
a macro's declaration provides information about
the names of the symbols that the macro generates.
When a macro declaration provides a list of names,
it's guaranteed to produce only declarations that use those names,
which helps you understand and debug the generated code.
Here's the full declaration of `@OptionSet`:

```swift
@attached(member, names: named(RawValue), named(rawValue),
        named(`init`), arbitrary)
@attached(conformance)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

In the declaration above,
the `@attached(member)` macro includes arguments after the `named:` label
for each of the symbols that the `@OptionSet` macro generates.
The macro adds declarations for symbols named
`RawValue`, `rawValue`, and `init` ---
because those names are known ahead of time,
the macro declaration lists them explicitly.

The macro declaration also includes `arbitrary` after the list of names,
allowing the macro to generate declarations
whose names aren't known until you use the macro.
In this case,
for each case in the private `Options` enumeration,
`@OptionSet` generates a corresponding declaration with the same name.

For more information,
including a full list of macro roles,
see <doc:Attributes#attached> and <doc:Attributes#freestanding>
in <doc:Attributes>

## Macro Expansion

As part of building Swift code that uses macros,
the compiler and the macro's implementation
pass that code back and forth to expand the macros.

Macros are expanded as follows:

1. The compiler reads the code,
   creating an in-memory representation of the syntax.

1. The compiler sends part of the in-memory representation
   to the macro implementation,
   which expands the macro.

1. The compiler replaces the macro call with its expanded form.

1. The compiler continues with compilation,
   using the expanded source code.

![](macro-expansion-full)

To go through the specific steps,
consider the following code:

```
let magicNumber = #fourCharacterCode("ABCD")
```

The `#fourCharacterCode` macro takes a string that's four characters long
and returns a unsigned 32-bin integer
that corresponds to the ASCII values in the string joined together.
Some file formats use a integers like this to identify data,
because they're compact but still readable in a debugger.
The <doc:Macros#Implementing-Macros> section below
shows how to implement this macro.

To expand the macros in the code above,
the compiler reads the Swift file
and creates an in-memory representation of that code
known an as *abstract syntax tree* or AST.
The AST makes the code's meaning and structure explicit,
which makes it easier to write code that interacts with that structure ---
like a compiler or a macro implementation.
Here's a representation of the AST for the code above,
slightly simplified by omitting some extra detail.

![](macro-ast-original)

<!-- XXX
walk through the AST
don't assume people know how to read this kind of diagram
-->

The compiler also ensures that the input code is valid Swift:
for example, that the input to macros is syntactically valid
and that the types of values match.
For example, in the code above,
it checks that the argument to `#fourCharacterCode` is a string.
<!-- XXX trying to avoid jargon "type checking" here -->

The compiler finds the places in the code where you call a macro,
and loads the external binary that implements those macros.
For each macro call,
the compiler passes part of the AST to that macro's implementation.
<!-- behind the scenes, the AST is serialized thru JSON -->
Here's a representation of that partial AST:

[XXX placeholder art]

- Macro call
    - Macro name: `fourCharacterCode`
    - Macro rguments
        - String literal `"ABCD"`

The implementation of a macro
operates only on the code that contains the macro.
In this example,
the implementation of the `#fourCharacterCode` macro
reads this partial AST that contains only the macro call.
A macro can't depend on code outside of the place where it's used.

The implementation of `#fourCharacterCode`
generates a new AST containing the expanded code.
Here's what that code returns to the compiler:

[XXX placeholder art]

- Integer literal: `1145258561`

When the compiler gets this expansion back,
it replaces the AST element that contains the macro call
with the element that contains the macro's expansion.
After macro expansion,
the compiler checks again to ensure
the program is still syntactically valid Swift
and the all the types are correct.
That produces a final AST that can be compiled as usual:

[XXX placeholder art]

- Constant declaration
    - Constant name: `magicNumber`
    - Constant value
        - Integer literal: `1145258561`

This AST corresponds to Swift code like this:

```
let magicNumber = 1145258561
```

In this example, the input source code has only one macro,
but a real program could have several instances of the same macro
and several calls to different macros.
The compiler expands macros one at a time.

If one macro appears inside another,
the outer macro is expanded first ---
this lets the outer macro modify the inner macro before it's expanded.

<!--

OUTLINE bits for the future

- Macros can be nested.
  Nested macros are expanded from the outside in.
  XXX TR: Is there any limit to nesting?
  XXX TR: Is it valid to nest like this -- if so, anything to note about it?

  ```
  let something = #someMacro {
      struct A { }
      @someMacro struct B { }
  }
  ```

- Macro recursion is limited.
  One macro can call another,
  but a given macro can't directly or indirectly call itself.
  The result of macro expansion can include other macros,
  but it can't include a macro that uses this macro in its expansion
  or declare a new macro.
  (XXX likely need to iterate with Doug here)

-->

## Implementing a Macro

To implement a macro, you make two parts:
A type that performs the macro expansion,
and a library that declares the macro to expose it as API.
These parts are built separately from code that uses the macro,
even if you're developing the macro and its clients together,
because the macro implementation runs
as part of building the macro's clients.

To create a new macro using Swift Package Manager,
run `swift package init --type macro` ---
this creates several files,
including a template for a macro implementation and declaration.
To add macros to an existing project,
add a target for the macro implementation
and a target for the macro library.
For example,
you can add something like the following to your `Package.swift` file,
changing the names to match your project:

```swift
targets: [
    // Macro implementation that performs the source transformations
    .macro(
        name: "MyProjectMacros",
        dependencies: [
            .product(name: "SwiftSyntaxMacros", package: "swift-syntax"),
            .product(name: "SwiftCompilerPlugin", package: "swift-syntax")
        ]
    ),

    // Library that exposes a macro as part of its API
    .target(name: "MyProject", dependencies: ["MyProjectMacros"]),
]
```

<!-- XXX additional framing of the code listing above -->

The implementation of a macro is a Swift type
that uses the [SwiftSyntax][] module to interact with an AST.
If you're adding macros to an existing project,
add a dependency on SwiftSyntax in your `Package.swift` file:

[SwiftSyntax]: http://github.com/apple/swift-syntax/

```swift
dependencies: [
    .package(url: "https://github.com/apple/swift-syntax.git", from: "509.0.0-swift-5.9-DEVELOPMENT-SNAPSHOT-2023-04-25-b"),
],
```

<!-- XXX TR:
Is there tag that's less likely to change over time
that this example can use instead?
-->

Depending on your macro's role,
there's a corresponding protocol from SwiftSystem
that the macro implementation conforms to.
For example,
consider `#fourCharacterCode` from the previous section.
Here's a structure that implements that macro:

```swift
public struct FourCharacterCode: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        guard let argument = node.argumentList.first?.expression,
              let segments = argument.as(StringLiteralExprSyntax.self)?.segments,
              segments.count == 1,
              case .stringSegment(let literalSegment)? = segments.first
        else {
            throw CustomError.message("Need a static string")
        }

        let string = literalSegment.content.text
        guard let result = fourCharacterCode(for: string) else {
            throw CustomError.message("Invalid four-character code")
        }

        return "\(raw: result)"
    }
}

private func fourCharacterCode(for characters: String) -> UInt32? {
    guard characters.count == 4 else { return nil }

    var result: UInt32 = 0
    for character in characters {
        result = result << 8
        guard let asciiValue = character.asciiValue else { return nil }
        result += UInt32(asciiValue)
    }
    return result.bigEndian
}
```

This is a freestanding macro that produces an expression,
so the `FourCharacterCode` type that implements the macro
conforms to the `ExpressionMacro` protocol.
The `ExpressionMacro` protocol has one requirement,
a `expansion(of:in:)` method that expands the AST.
For the list of macro roles and their corresponding SwiftSystem protocols,
see <doc:Attributes#attached> and <doc:Attributes:freestanding>
in <doc:Attributes>

To expand the `#fourCharacterCode` macro,
Swift sends the AST for the code that uses this macro
to the library that contains the macro implementation.
Inside the library, Swift calls `FourCharacterCode.expansion(of:in:)`,
passing in the AST and the context as arguments to the method.
The implementation of `expansion(of:in:)`
finds the string that was passed as an argument to `#fourCharacterCode`
and calculates the corresponding integer literal value.

In the example above,
the first `guard` block extracts the string literal from the AST,
and the second `gaurd` block
calls the private `FourCharacterCode(for:)` function.
Both of these blocks of code throw an error if the macro is use incorrectly ---
the error message becomes a compiler error
at the malformed call site.
For example,
if you try to call the macro as `#fourCharacterCode("AB" + "CD")`
the compiler shows the error "Need a static string".
<!-- XXX generate good diagnostics when your macro is used wrong -->

The `expansion(of:in:)` method returns an instance of `ExprSyntax`,
a type from SwiftSyntax that represents an expression in an AST.
Because this type conforms to the `StringLiteralConvertible` protocol,
the macro implementation uses a string literal
as a lightweight syntax to create its result.
All of the SwiftSyntax types that you return from a macro implementation
conform to `StringLiteralConvertible`,
so you can use this approach when implementing any kind  of macro.

<!-- XXX contrast the `\(raw:)` and non-raw version.  -->

<!--
The return-a-string APIs come from here

https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Syntax%2BStringInterpolation.swift
-->


<!--
XXX OUTLINE:

- Note:
  Behind the scenes, Swift serializes and deserializes the AST,
  to pass the data across process boundaries,
  but your macro implementation doesn't need to deal with any of that.

- This method is also passed a macro-expansion context, which you use to:

    + Generate unique symbol names
    + Produce diagnostics (`Diagnostic` and `SimpleDiagnosticMessage`)
    + Find a node's location in source

- Macro expansion happens in their surrounding context.
  A macro can affect that environment if it needs to â€”
  and a macro that has bugs can interfere with that environment.
  (XXX Give guidance on when you'd do this.  It should be rare.)

- Generated symbol names let a macro
  avoid accidentally interacting with symbols in that environment.
  To generate a unique symbol name,
  call the `MacroExpansionContext.makeUniqueName()` method.

- Ways to create a syntax node include
  Making an instance of the `Syntax` struct,
  or `SyntaxToken`
  or `ExprSyntax`.
  (Need to give folks some general ideas,
  and enough guidance so they can sort through
  all the various `SwiftSyntax` node types and find the right one.)

- Attached macros follow the same general model as expression macros,
  but with more moving parts.

- Pick the subprotocol of `AttachedMacro` to conform to,
  depending on which kind of attached macro you're making.
  [This is probably a table]

  + `AccessorMacro` goes with `@attached(accessor)`
  + `ConformanceMacro` goes with `@attached(conformance)`
    [XXX missing from the list under Declaring a Macro]
  + `MemberMacro` goes with `@attached(member)`
  + `PeerMacro` goes with `@attached(peer)`
  + `MemberAttributeMacro` goes with `@member(memberAttribute)`

- Code example of conforming to `MemberMacro`.

  ```
  static func expansion<
    Declaration: DeclGroupSyntax,
    Context: MacroExpansionContext
  >(
    of node: AttributeSyntax,
    providingMembersOf declaration: Declaration,
    in context: Context
  ) throws -> [DeclSyntax]
  ```

- Adding a new member by making an instance of `Declaration`,
  and returning it as part of the `[DeclSyntax]` list.

-->

## Debugging Macros

Macros are well suited to development using tests:
they transform one AST into another AST,
without depending on any external state,
and without causing any any side effects.
In addition, you can create syntax nodes from a string literal,
which simplifies setting up the input for a unit test.
You can also read the `description` property of an AST
to get a string that you can compare to an expected value.
For example,
here's a test of the `#fourCharacterCode` macro from previous sections:

```swift
let source: SourceFileSyntax =
"""
let abcd = #fourCharacterCode("ABCD")
"""

let file = BasicMacroExpansionContext.KnownSourceFile(
    moduleName: "MyModule",
    fullFilePath: "test.swift"
)

let context = BasicMacroExpansionContext(sourceFiles: [source: file])

let transformedSF = source.expand(
    macros:["fourCharacterCode": FourCC.self],
    in: context
)

let expectedDescription =
"""
let abcd = 1145258561
"""

precondition(transformedSF.description == expectedDescription)
```

The example above tests the macro using a precondition,
but you could use a testing framework instead.

<!-- XXX OUTLINE:

- Ways to view the macro expansion while debugging.
  The SE prototype provides `-Xfrontend -dump-macro-expansions` for this.
  [XXX TR: Is this flag what we should suggest folks use,
  or will there be better command-line options coming?]

- Use diagnostics for macros that have constraints/requirements
  so your code can give a meaningful error to users when those aren't met,
  instead of letting the compiler try & fail to build the generated code.

- idempotency and sandboxing
-->

<!-- XXX
Additional APIs and concepts to introduce in the future,
in no particular order:

- Using `SyntaxRewriter` and the visitor pattern for modifying the AST

- Adding a suggested correction using `FixIt`

- concept of trivia

- `TokenSyntax`
-->

<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->
