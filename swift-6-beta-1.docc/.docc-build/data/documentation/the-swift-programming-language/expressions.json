{"abstract":[{"type":"text","text":"Access, modify, and assign values."}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"text":"In Swift, there are four kinds of expressions:","type":"text"},{"type":"text","text":" "},{"type":"text","text":"prefix expressions, infix expressions, primary expressions, and postfix expressions."},{"text":" ","type":"text"},{"type":"text","text":"Evaluating an expression returns a value,"},{"text":" ","type":"text"},{"type":"text","text":"causes a side effect, or both."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Prefix and infix expressions let you"},{"type":"text","text":" "},{"type":"text","text":"apply operators to smaller expressions."},{"text":" ","type":"text"},{"type":"text","text":"Primary expressions are conceptually the simplest kind of expression,"},{"type":"text","text":" "},{"text":"and they provide a way to access values.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Postfix expressions,"},{"type":"text","text":" "},{"text":"like prefix and infix expressions,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"let you build up more complex expressions"},{"type":"text","text":" "},{"text":"using postfixes such as function calls and member access.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Each kind of expression is described in detail"},{"text":" ","type":"text"},{"type":"text","text":"in the sections below."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"try-operator","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"await-operator"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"prefix-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"infix-expressions","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" \\","type":"text"}]}],"name":"Grammar of an expression","type":"aside"},{"type":"heading","anchor":"Prefix-Expressions","level":2,"text":"Prefix Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Prefix expressions"}]},{"text":" combine","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an optional prefix operator with an expression."},{"type":"text","text":" "},{"text":"Prefix operators take one argument,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the expression that follows them."}]},{"inlineContent":[{"text":"For information about the behavior of these operators,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"type":"text","text":" and "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","isActive":true},{"type":"text","text":"."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"prefix-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"prefix-operator","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"prefix-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"in-out-expression"}],"type":"emphasis"}]}],"name":"Grammar of a prefix expression","type":"aside"},{"type":"heading","anchor":"In-Out-Expression","text":"In-Out Expression","level":3},{"inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"in-out expression"}]},{"type":"text","text":" marks a variable"},{"type":"text","text":" "},{"type":"text","text":"that’s being passed"},{"type":"text","text":" "},{"text":"as an in-out argument to a function call expression.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["&<#expression#>"]},{"inlineContent":[{"type":"text","text":"For more information about in-out parameters and to see an example,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In-out expressions are also used"},{"type":"text","text":" "},{"text":"when providing a non-pointer argument","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in a context where a pointer is needed,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Implicit-Conversion-to-a-Pointer-Type"},{"text":".","type":"text"}]},{"name":"Grammar of an in-out expression","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"in-out-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"&","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]}]}]},{"type":"heading","level":3,"text":"Try Operator","anchor":"Try-Operator"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"try expression","type":"text"}]},{"text":" consists of the ","type":"text"},{"type":"codeVoice","code":"try"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","code":["try <#expression#>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of a "},{"type":"codeVoice","code":"try"},{"text":" expression is the value of the ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-try expression"}]},{"text":" consists of the ","type":"text"},{"code":"try?","type":"codeVoice"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that can throw an error."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"swift","code":["try? <#expression#>"]},{"inlineContent":[{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" doesn’t throw an error,"},{"text":" ","type":"text"},{"type":"text","text":"the value of the optional-try expression"},{"type":"text","text":" "},{"text":"is an optional containing the value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Otherwise, the value of the optional-try expression is ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"forced-try expression","type":"text"}]},{"text":" consists of the ","type":"text"},{"type":"codeVoice","code":"try!"},{"text":" operator","type":"text"},{"type":"text","text":" "},{"text":"followed by an expression that can throw an error.","type":"text"},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["try! <#expression#>"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The value of a forced-try expression is the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"If the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" throws an error,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a runtime error is produced."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the expression on the left-hand side of an infix operator"},{"type":"text","text":" "},{"type":"text","text":"is marked with "},{"type":"codeVoice","code":"try"},{"text":", ","type":"text"},{"code":"try?","type":"codeVoice"},{"type":"text","text":", or "},{"code":"try!","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"that operator applies to the whole infix expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"That said, you can use parentheses to be explicit about the scope of the operator’s application."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ try applies to both function calls","sum = try someThrowingFunction() + anotherThrowingFunction()","","\/\/ try applies to both function calls","sum = try (someThrowingFunction() + anotherThrowingFunction())","","\/\/ Error: try applies only to the first function call","sum = (try someThrowingFunction()) + anotherThrowingFunction()"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"try","type":"codeVoice"},{"text":" expression can’t appear on the right-hand side of an infix operator,","type":"text"},{"text":" ","type":"text"},{"text":"unless the infix operator is the assignment operator","type":"text"},{"type":"text","text":" "},{"text":"or the ","type":"text"},{"type":"codeVoice","code":"try"},{"text":" expression is enclosed in parentheses.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If an expression includes both the ","type":"text"},{"type":"codeVoice","code":"try"},{"type":"text","text":" and "},{"type":"codeVoice","code":"await"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"try","type":"codeVoice"},{"text":" operator must appear first.","type":"text"}]},{"inlineContent":[{"text":"For more information and to see examples of how to use ","type":"text"},{"type":"codeVoice","code":"try"},{"text":", ","type":"text"},{"type":"codeVoice","code":"try?"},{"type":"text","text":", and "},{"code":"try!","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"style":"note","name":"Grammar of a try expression","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"try-operator","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"try"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"try"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"code":"try","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]}],"type":"paragraph"}],"type":"aside"},{"anchor":"Await-Operator","level":3,"type":"heading","text":"Await Operator"},{"inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"await expression"}]},{"type":"text","text":" consists of the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"type":"text","text":"followed by an expression that uses the result of an asynchronous operation."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["await <#expression#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of an "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression is the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"An expression marked with ","type":"text"},{"code":"await","type":"codeVoice"},{"type":"text","text":" is called a "},{"inlineContent":[{"type":"text","text":"potential suspension point"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Execution of an asynchronous function can be suspended"},{"type":"text","text":" "},{"type":"text","text":"at each expression that’s marked with "},{"type":"codeVoice","code":"await"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"In addition,"},{"text":" ","type":"text"},{"type":"text","text":"execution of concurrent code is never suspended at any other point."},{"text":" ","type":"text"},{"text":"This means code between potential suspension points","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can safely update state that requires temporarily breaking invariants,"},{"type":"text","text":" "},{"type":"text","text":"provided that it completes the update"},{"type":"text","text":" "},{"type":"text","text":"before the next potential suspension point."}]},{"inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression can appear only within an asynchronous context,"},{"type":"text","text":" "},{"type":"text","text":"such as the trailing closure passed to the "},{"type":"codeVoice","code":"async(priority:operation:)"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"It can’t appear in the body of a "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"text":"or in an autoclosure of synchronous function type.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When the expression on the left-hand side of an infix operator","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is marked with the "},{"code":"await","type":"codeVoice"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that operator applies to the whole infix expression."},{"type":"text","text":" "},{"type":"text","text":"That said, you can use parentheses"},{"type":"text","text":" "},{"type":"text","text":"to be explicit about the scope of the operator’s application."}]},{"type":"codeListing","code":["\/\/ await applies to both function calls","sum = await someAsyncFunction() + anotherAsyncFunction()","","\/\/ await applies to both function calls","sum = await (someAsyncFunction() + anotherAsyncFunction())","","\/\/ Error: await applies only to the first function call","sum = (await someAsyncFunction()) + anotherAsyncFunction()"],"syntax":"swift"},{"inlineContent":[{"text":"An ","type":"text"},{"code":"await","type":"codeVoice"},{"text":" expression can’t appear on the right-hand side of an infix operator,","type":"text"},{"text":" ","type":"text"},{"text":"unless the infix operator is the assignment operator","type":"text"},{"text":" ","type":"text"},{"text":"or the ","type":"text"},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression is enclosed in parentheses."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If an expression includes both the "},{"type":"codeVoice","code":"await"},{"text":" and ","type":"text"},{"code":"try","type":"codeVoice"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"try","type":"codeVoice"},{"text":" operator must appear first.","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Grammar of an await expression","style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"await-operator"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"await"}]}]}]},{"type":"heading","level":2,"text":"Infix Expressions","anchor":"Infix-Expressions"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Infix expressions"}],"type":"emphasis"},{"type":"text","text":" combine"},{"type":"text","text":" "},{"type":"text","text":"an infix binary operator with the expression that it takes"},{"type":"text","text":" "},{"type":"text","text":"as its left- and right-hand arguments."},{"type":"text","text":" "},{"text":"It has the following form:","type":"text"}]},{"type":"codeListing","code":["<#left-hand argument#> <#operator#> <#right-hand argument#>"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the behavior of these operators,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"text":" and ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","type":"reference"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"overridingTitle":"Operator Declarations","overridingTitleInlineContent":[{"text":"Operator Declarations","type":"text"}],"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","isActive":true},{"type":"text","text":"."}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"At parse time,"},{"type":"text","text":" "},{"text":"an expression made up of infix operators is represented","type":"text"},{"type":"text","text":" "},{"text":"as a flat list.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This list is transformed into a tree"},{"type":"text","text":" "},{"type":"text","text":"by applying operator precedence."},{"type":"text","text":" "},{"type":"text","text":"For example, the expression "},{"type":"codeVoice","code":"2 + 3 * 5"},{"type":"text","text":" "},{"text":"is initially understood as a flat list of five items,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"2"},{"text":", ","type":"text"},{"type":"codeVoice","code":"+"},{"type":"text","text":", "},{"code":"3","type":"codeVoice"},{"type":"text","text":", "},{"code":"*","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"5"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This process transforms it into the tree (2 + (3 * 5))."}],"type":"paragraph"}],"name":"Note"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"infix-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"infix-operator"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"prefix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"infix-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"assignment-operator"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"try-operator","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"await-operator","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"prefix-expression","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional-operator"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"try-operator","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"await-operator","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix-expression"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expression"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-operator"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"infix-expressions","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"infix-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"infix-expressions"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]}],"name":"Grammar of an infix expression","type":"aside","style":"note"},{"anchor":"Assignment-Operator","text":"Assignment Operator","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"assignment operator"}]},{"text":" sets a new value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for a given expression."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"code":["<#expression#> = <#value#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The value of the "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"is set to the value obtained by evaluating the ","type":"text"},{"inlineContent":[{"text":"value","type":"text"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"If the ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" is a tuple,"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"value"}]},{"type":"text","text":" must be a tuple"},{"type":"text","text":" "},{"text":"with the same number of elements.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"(Nested tuples are allowed.)"},{"type":"text","text":" "},{"text":"Assignment is performed from each part of the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"value","type":"text"}]},{"type":"text","text":" "},{"text":"to the corresponding part of the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"code":["(a, _, (b, c)) = (\"test\", 9.45, (12, 3))","\/\/ a is \"test\", b is 12, c is 3, and 9.45 is ignored"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The assignment operator doesn’t return any value."}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"assignment-operator","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"="}]}]}],"style":"note","name":"Grammar of an assignment operator","type":"aside"},{"anchor":"Ternary-Conditional-Operator","type":"heading","text":"Ternary Conditional Operator","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"ternary conditional operator","type":"text"}]},{"text":" evaluates to one of two given values","type":"text"},{"type":"text","text":" "},{"text":"based on the value of a condition.","type":"text"},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}]},{"code":["<#condition#> ? <#expression used if true#> : <#expression used if false#>"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"type":"emphasis","inlineContent":[{"text":"condition","type":"text"}]},{"text":" evaluates to ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"the conditional operator evaluates the first expression","type":"text"},{"type":"text","text":" "},{"text":"and returns its value.","type":"text"},{"text":" ","type":"text"},{"text":"Otherwise, it evaluates the second expression","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and returns its value."},{"type":"text","text":" "},{"type":"text","text":"The unused expression isn’t evaluated."}]},{"inlineContent":[{"type":"text","text":"For an example that uses the ternary conditional operator,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators#Ternary-Conditional-Operator","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Grammar of a conditional operator","type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional-operator"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"?","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]}]}]},{"level":3,"text":"Type-Casting Operators","type":"heading","anchor":"Type-Casting-Operators"},{"type":"paragraph","inlineContent":[{"text":"There are four type-casting operators:","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"as"},{"text":" operator,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"as?"},{"text":" operator,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the "},{"code":"as!","type":"codeVoice"},{"text":" operator.","type":"text"}]},{"inlineContent":[{"text":"They have the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["<#expression#> is <#type#>","<#expression#> as <#type#>","<#expression#> as? <#type#>","<#expression#> as! <#type#>"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"is","type":"codeVoice"},{"type":"text","text":" operator checks at runtime whether the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"can be cast to the specified "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It returns "},{"code":"true","type":"codeVoice"},{"type":"text","text":" if the "},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" can be cast to the specified ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"otherwise, it returns "},{"code":"false","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" operator performs a cast"},{"type":"text","text":" "},{"text":"when it’s known at compile time","type":"text"},{"text":" ","type":"text"},{"text":"that the cast always succeeds,","type":"text"},{"type":"text","text":" "},{"text":"such as upcasting or bridging.","type":"text"},{"text":" ","type":"text"},{"text":"Upcasting lets you use an expression as an instance of its type’s supertype,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"without using an intermediate variable."},{"type":"text","text":" "},{"type":"text","text":"The following approaches are equivalent:"}]},{"type":"codeListing","code":["func f(_ any: Any) { print(\"Function for Any\") }","func f(_ int: Int) { print(\"Function for Int\") }","let x = 10","f(x)","\/\/ Prints \"Function for Int\"","","let y: Any = x","f(y)","\/\/ Prints \"Function for Any\"","","f(x as Any)","\/\/ Prints \"Function for Any\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Bridging lets you use an expression of"},{"text":" ","type":"text"},{"type":"text","text":"a Swift standard library type such as "},{"code":"String","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"as its corresponding Foundation type such as "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"without needing to create a new instance."},{"type":"text","text":" "},{"text":"For more information on bridging,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"text":"performs a conditional cast of the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" ","type":"text"},{"type":"text","text":"to the specified "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"The ","type":"text"},{"type":"codeVoice","code":"as?"},{"type":"text","text":" operator returns an optional of the specified "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"At runtime, if the cast succeeds,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the value of "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"type":"text","text":" is wrapped in an optional and returned;"},{"text":" ","type":"text"},{"text":"otherwise, the value returned is ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If casting to the specified "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"text":" ","type":"text"},{"text":"is guaranteed to fail or is guaranteed to succeed,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a compile-time error is raised."}]},{"inlineContent":[{"type":"text","text":"The "},{"code":"as!","type":"codeVoice"},{"type":"text","text":" operator performs a forced cast of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" to the specified "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The ","type":"text"},{"code":"as!","type":"codeVoice"},{"type":"text","text":" operator returns a value of the specified "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":", not an optional type."},{"text":" ","type":"text"},{"type":"text","text":"If the cast fails, a runtime error is raised."},{"type":"text","text":" "},{"text":"The behavior of ","type":"text"},{"type":"codeVoice","code":"x as! T"},{"text":" is the same as the behavior of ","type":"text"},{"code":"(x as? T)!","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about type casting"},{"type":"text","text":" "},{"text":"and to see examples that use the type-casting operators,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","type":"reference","isActive":true},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-operator"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"is","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-casting-operator","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"as"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-operator"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"as","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"type-casting-operator"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"as"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"}]}],"name":"Grammar of a type-casting operator","style":"note","type":"aside"},{"type":"heading","level":2,"anchor":"Primary-Expressions","text":"Primary Expressions"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Primary expressions"}]},{"text":" ","type":"text"},{"type":"text","text":"are the most basic kind of expression."},{"type":"text","text":" "},{"text":"They can be used as expressions on their own,","type":"text"},{"text":" ","type":"text"},{"text":"and they can be combined with other tokens","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make prefix expressions, infix expressions, and postfix expressions."}],"type":"paragraph"},{"type":"aside","name":"Grammar of a primary expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic-argument-clause"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"literal-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"conditional-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"closure-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"parenthesized-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"tuple-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"implicit-member-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"text":"primary-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"wildcard-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"macro-expansion-expression"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"primary-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"key-path-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"primary-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"selector-expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-string-expression"}]}],"type":"paragraph"}],"style":"note"},{"type":"heading","anchor":"Literal-Expression","level":3,"text":"Literal Expression"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"literal expression"}]},{"text":" consists of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"either an ordinary literal (such as a string or a number),"},{"type":"text","text":" "},{"text":"an array or dictionary literal,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or a playground literal."}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"text","text":" "},{"text":"Prior to Swift 5.9,","type":"text"},{"type":"text","text":" "},{"text":"the following special literals were recognized:","type":"text"},{"type":"text","text":" "},{"code":"#column","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"#dsohandle"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"#fileID"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"codeVoice","code":"#file"},{"text":",","type":"text"},{"type":"text","text":" "},{"code":"#function","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"#line"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These are now implemented as macros in the Swift standard library:"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/column()","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()","isActive":true,"type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()","isActive":true},{"type":"text","text":","},{"text":" ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","type":"reference","isActive":true},{"type":"text","text":","},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()","type":"reference"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()"},{"text":".","type":"text"}]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"array literal"}]},{"type":"text","text":" is"},{"text":" ","type":"text"},{"type":"text","text":"an ordered collection of values."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["[<#value 1#>, <#value 2#>, <#...#>]"]},{"inlineContent":[{"text":"The last expression in the array can be followed by an optional comma.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The value of an array literal has type "},{"code":"[T]","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"where ","type":"text"},{"type":"codeVoice","code":"T"},{"text":" is the type of the expressions inside it.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If there are expressions of multiple types,"},{"type":"text","text":" "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is their closest common supertype."},{"type":"text","text":" "},{"text":"Empty array literals are written using an empty","type":"text"},{"type":"text","text":" "},{"text":"pair of square brackets and can be used to create an empty array of a specified type.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var emptyArray: [Double] = []"]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"dictionary literal"}],"type":"emphasis"},{"type":"text","text":" is"},{"text":" ","type":"text"},{"text":"an unordered collection of key-value pairs.","type":"text"},{"type":"text","text":" "},{"text":"It has the following form:","type":"text"}]},{"syntax":"swift","code":["[<#key 1#>: <#value 1#>, <#key 2#>: <#value 2#>, <#...#>]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The last expression in the dictionary can be followed by an optional comma.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The value of a dictionary literal has type "},{"type":"codeVoice","code":"[Key: Value]"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"where "},{"code":"Key","type":"codeVoice"},{"type":"text","text":" is the type of its key expressions"},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"type":"codeVoice","code":"Value"},{"type":"text","text":" is the type of its value expressions."},{"text":" ","type":"text"},{"text":"If there are expressions of multiple types,","type":"text"},{"type":"text","text":" "},{"code":"Key","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Value"},{"text":" are the closest common supertype","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for their respective values."},{"text":" ","type":"text"},{"text":"An empty dictionary literal is written as","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a colon inside a pair of brackets ("},{"type":"codeVoice","code":"[:]"},{"text":")","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to distinguish it from an empty array literal."},{"text":" ","type":"text"},{"type":"text","text":"You can use an empty dictionary literal to create an empty dictionary literal"},{"type":"text","text":" "},{"text":"of specified key and value types.","type":"text"}]},{"code":["var emptyDictionary: [String: Double] = [:]"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"playground literal","type":"text"}]},{"type":"text","text":" "},{"text":"is used by Xcode to create an interactive representation","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of a color, file, or image within the program editor."},{"text":" ","type":"text"},{"text":"Playground literals in plain text outside of Xcode","type":"text"},{"type":"text","text":" "},{"text":"are represented using a special literal syntax.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information on using playground literals in Xcode,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"isActive":true,"identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc","type":"reference"},{"text":" ","type":"text"},{"type":"text","text":"in Xcode Help."}]},{"name":"Grammar of a literal expression","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"literal-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"literal"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"literal-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"array-literal","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-literal"}]},{"type":"text","text":" | "},{"inlineContent":[{"text":"playground-literal","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"["}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"array-literal-items"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":"]","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"array-literal-items"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal-item"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal-item"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-literal-items"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"array-literal-item","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"dictionary-literal","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"dictionary-literal-items"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"]"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal-items","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal-item","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"dictionary-literal-item","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"dictionary-literal-items"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"dictionary-literal-item"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"playground-literal","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"#colorLiteral"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"red"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"green","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"blue"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"alpha"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"playground-literal"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"#fileLiteral"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"resourceName","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"playground-literal"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#imageLiteral"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"resourceName"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}],"type":"paragraph"}],"type":"aside","style":"note"},{"type":"heading","text":"Self Expression","level":3,"anchor":"Self-Expression"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"self"},{"text":" expression is an explicit reference to the current type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or instance of the type in which it occurs."},{"text":" ","type":"text"},{"type":"text","text":"It has the following forms:"}],"type":"paragraph"},{"code":["self","self.<#member name#>","self[<#subscript index#>]","self(<#initializer arguments#>)","self.init(<#initializer arguments#>)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In an initializer, subscript, or instance method, "},{"code":"self","type":"codeVoice"},{"type":"text","text":" refers to the current"},{"type":"text","text":" "},{"text":"instance of the type in which it occurs. In a type method,","type":"text"},{"text":" ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" refers to the current type in which it occurs."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"self","type":"codeVoice"},{"text":" expression is used to specify scope when accessing members,","type":"text"},{"text":" ","type":"text"},{"text":"providing disambiguation when there’s","type":"text"},{"text":" ","type":"text"},{"text":"another variable of the same name in scope,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as a function parameter."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"code":["class SomeClass {","    var greeting: String","    init(greeting: String) {","        self.greeting = greeting","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a mutating method of a value type,"},{"type":"text","text":" "},{"text":"you can assign a new instance of that value type to ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"code":["struct Point {","    var x = 0.0, y = 0.0","    mutating func moveBy(x deltaX: Double, y deltaY: Double) {","        self = Point(x: x + deltaX, y: y + deltaY)","    }","}"],"syntax":"swift","type":"codeListing"},{"name":"Grammar of a self expression","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"self-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"self","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"self-method-expression"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"self-subscript-expression"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"text":"self-initializer-expression","type":"text"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"self-method-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"self"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"self-subscript-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"self","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"["}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"text":"function-call-argument-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"]","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-initializer-expression"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"self"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"init"}]}],"type":"paragraph"}],"type":"aside","style":"note"},{"level":3,"type":"heading","text":"Superclass Expression","anchor":"Superclass-Expression"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass expression"}]},{"text":" lets a class","type":"text"},{"type":"text","text":" "},{"text":"interact with its superclass.","type":"text"},{"text":" ","type":"text"},{"text":"It has one of the following forms:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["super.<#member name#>","super[<#subscript index#>]","super.init(<#initializer arguments#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first form is used to access a member of the superclass."},{"text":" ","type":"text"},{"text":"The second form is used to access the superclass’s subscript implementation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The third form is used to access an initializer of the superclass."}]},{"inlineContent":[{"text":"Subclasses can use a superclass expression","type":"text"},{"type":"text","text":" "},{"text":"in their implementation of members, subscripting, and initializers","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to make use of the implementation in their superclass."}],"type":"paragraph"},{"style":"note","name":"Grammar of a superclass expression","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"superclass-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"superclass-method-expression"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"text":"superclass-subscript-expression","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"text":"superclass-initializer-expression","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass-method-expression"}]},{"text":" → ","type":"text"},{"inlineContent":[{"code":"super","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"superclass-subscript-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"super"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"[","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"function-call-argument-list","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"]"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"superclass-initializer-expression"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"super"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"init","type":"codeVoice"}],"type":"strong"}]}]},{"anchor":"Conditional-Expression","level":3,"type":"heading","text":"Conditional Expression"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"conditional expression"}]},{"type":"text","text":" evaluates to one of several given values"},{"type":"text","text":" "},{"text":"based on the value of a condition.","type":"text"},{"type":"text","text":" "},{"text":"It has one the following forms:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if <#condition 1#> {","   <#expression used if condition 1 is true#>","} else if <#condition 2#> {","   <#expression used if condition 2 is true#>","} else {","   <#expression used if both conditions are false#>","}","","switch <#expression#> {","case <#pattern 1#>:","    <#expression 1#>","case <#pattern 2#> where <#condition#>:","    <#expression 2#>","default:","    <#expression 3#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A conditional expression"},{"type":"text","text":" "},{"type":"text","text":"has the same behavior and syntax as an "},{"type":"codeVoice","code":"if"},{"text":" statement or a ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"except for the differences that the paragraphs below describe."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A conditional expression appears only in the following contexts:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the value assigned to a variable."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"As the initial value in a variable or constant declaration."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the error thrown by a "},{"code":"throw","type":"codeVoice"},{"text":" expression.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"As the value returned by a function, closure, or property getter."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As the value inside a branch of a conditional expression.","type":"text"}]}]}]},{"inlineContent":[{"text":"The branches of a conditional expression are exhaustive,","type":"text"},{"text":" ","type":"text"},{"text":"ensuring that the expression always produces a value","type":"text"},{"text":" ","type":"text"},{"text":"regardless of the condition.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This means each "},{"code":"if","type":"codeVoice"},{"type":"text","text":" branch needs a corresponding "},{"type":"codeVoice","code":"else"},{"type":"text","text":" branch."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each branch contains either a single expression,"},{"type":"text","text":" "},{"type":"text","text":"which is used as the value for the conditional expression"},{"type":"text","text":" "},{"type":"text","text":"when that branch’s conditional is true,"},{"type":"text","text":" "},{"text":"a ","type":"text"},{"type":"codeVoice","code":"throw"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"type":"text","text":"or a call to a function that never returns."}]},{"type":"paragraph","inlineContent":[{"text":"Each branch must produce a value of the same type.","type":"text"},{"type":"text","text":" "},{"text":"Because type checking of each branch is independent,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you sometimes need to specify the value’s type explicitly,"},{"text":" ","type":"text"},{"type":"text","text":"like when branches include different kinds of literals,"},{"text":" ","type":"text"},{"type":"text","text":"or when a branch’s value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"When you need to provide this information,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"add a type annotation to the variable that the result is assigned to,"},{"text":" ","type":"text"},{"type":"text","text":"or add an "},{"type":"codeVoice","code":"as"},{"type":"text","text":" cast to the branches’ values."}]},{"code":["let number: Double = if someCondition { 10 } else { 12.34 }","let number = if someCondition { 10 as Double } else { 12.34 }"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Inside a result builder,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"conditional expressions can appear"},{"text":" ","type":"text"},{"text":"only as the initial value of a variable or constant.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This behavior means when you write "},{"type":"codeVoice","code":"if"},{"type":"text","text":" or "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" in a result builder —"},{"text":" ","type":"text"},{"type":"text","text":"outside of a variable or constant declaration —"},{"type":"text","text":" "},{"type":"text","text":"that code is understood as a branch statement"},{"text":" ","type":"text"},{"type":"text","text":"and one of the result builder’s methods transforms that code."}],"type":"paragraph"},{"inlineContent":[{"text":"Don’t put a conditional expression in a ","type":"text"},{"type":"codeVoice","code":"try"},{"type":"text","text":" expression,"},{"type":"text","text":" "},{"type":"text","text":"even if one of the branches of a conditional expression is throwing."}],"type":"paragraph"},{"style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"conditional-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"if-expression"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"switch-expression"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"if-expression"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"if","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"condition-list"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"{"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"statement"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"}"}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"if-expression-tail"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"if-expression-tail","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"else"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"text":"if-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"if-expression-tail"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"else"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"{"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"statement"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"}","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"switch-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"switch"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"{","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"switch-expression-cases","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"}"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-cases"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"switch-expression-case","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"switch-expression-cases"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"switch-expression-case"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"case-label","type":"text"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"statement","type":"text"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"switch-expression-case","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"default-label","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"statement"}]}]}],"name":"Grammar of a conditional expression","type":"aside"},{"type":"heading","text":"Closure Expression","level":3,"anchor":"Closure-Expression"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"closure expression","type":"text"}]},{"text":" creates a closure,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"also known as a "},{"inlineContent":[{"text":"lambda","type":"text"}],"type":"emphasis"},{"type":"text","text":" or an "},{"inlineContent":[{"type":"text","text":"anonymous function"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"in other programming languages."},{"type":"text","text":" "},{"text":"Like a function declaration,","type":"text"},{"text":" ","type":"text"},{"text":"a closure contains statements,","type":"text"},{"text":" ","type":"text"},{"text":"and it captures constants and variables from its enclosing scope.","type":"text"},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"parameters"}]},{"text":" have the same form","type":"text"},{"type":"text","text":" "},{"text":"as the parameters in a function declaration,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Writing ","type":"text"},{"type":"codeVoice","code":"throws"},{"type":"text","text":" or "},{"type":"codeVoice","code":"async"},{"type":"text","text":" in a closure expression"},{"text":" ","type":"text"},{"text":"explicitly marks a closure as throwing or asynchronous.","type":"text"}]},{"type":"codeListing","code":["{ (<#parameters#>) async throws -> <#return type#> in","   <#statements#>","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If the body of a closure includes a ","type":"text"},{"type":"codeVoice","code":"throws"},{"type":"text","text":" statement or a "},{"type":"codeVoice","code":"try"},{"text":" expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that isn’t nested inside of a "},{"type":"codeVoice","code":"do"},{"text":" statement with exhaustive error handling,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the closure is understood to be throwing."},{"type":"text","text":" "},{"type":"text","text":"If a throwing closure throws errors of only a single type,"},{"type":"text","text":" "},{"type":"text","text":"the closure is understood as throwing that error type;"},{"text":" ","type":"text"},{"text":"otherwise, it’s understood as throwing ","type":"text"},{"code":"any Error","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Likewise, if the body includes an "},{"type":"codeVoice","code":"await"},{"type":"text","text":" expression,"},{"type":"text","text":" "},{"type":"text","text":"it’s understood to be asynchronous."}]},{"type":"paragraph","inlineContent":[{"text":"There are several special forms","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that allow closures to be written more concisely:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure can omit the types"},{"text":" ","type":"text"},{"type":"text","text":"of its parameters, its return type, or both."},{"type":"text","text":" "},{"text":"If you omit the parameter names and both types,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"omit the "},{"type":"codeVoice","code":"in"},{"text":" keyword before the statements.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If the omitted types can’t be inferred,"},{"type":"text","text":" "},{"type":"text","text":"a compile-time error is raised."}]}]},{"content":[{"inlineContent":[{"text":"A closure may omit names for its parameters.","type":"text"},{"type":"text","text":" "},{"text":"Its parameters are then implicitly named","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"$"},{"type":"text","text":" followed by their position:"},{"type":"text","text":" "},{"type":"codeVoice","code":"$0"},{"type":"text","text":", "},{"type":"codeVoice","code":"$1"},{"text":", ","type":"text"},{"type":"codeVoice","code":"$2"},{"text":", and so on.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure that consists of only a single expression"},{"type":"text","text":" "},{"type":"text","text":"is understood to return the value of that expression."},{"type":"text","text":" "},{"text":"The contents of this expression are also considered","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when performing type inference on the surrounding expression."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"The following closure expressions are equivalent:","type":"text"}]},{"type":"codeListing","code":["myFunction { (x: Int, y: Int) -> Int in","    return x + y","}","","myFunction { x, y in","    return x + y","}","","myFunction { return $0 + $1 }","","myFunction { $0 + $1 }"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"For information about passing a closure as an argument to a function,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Closure expressions can be used","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"without being stored in a variable or constant,"},{"text":" ","type":"text"},{"type":"text","text":"such as when you immediately use a closure as part of a function call."},{"type":"text","text":" "},{"text":"The closure expressions passed to ","type":"text"},{"type":"codeVoice","code":"myFunction"},{"text":" in code above are","type":"text"},{"type":"text","text":" "},{"text":"examples of this kind of immediate use.","type":"text"},{"text":" ","type":"text"},{"text":"As a result,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whether a closure expression is escaping or nonescaping depends"},{"type":"text","text":" "},{"type":"text","text":"on the surrounding context of the expression."},{"text":" ","type":"text"},{"text":"A closure expression is nonescaping","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"if it’s called immediately"},{"text":" ","type":"text"},{"text":"or passed as a nonescaping function argument.","type":"text"},{"type":"text","text":" "},{"text":"Otherwise, the closure expression is escaping.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For more information about escaping closures, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures"},{"text":".","type":"text"}]},{"anchor":"Capture-Lists","type":"heading","level":4,"text":"Capture Lists"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, a closure expression captures"},{"text":" ","type":"text"},{"type":"text","text":"constants and variables from its surrounding scope"},{"text":" ","type":"text"},{"text":"with strong references to those values.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You can use a "},{"inlineContent":[{"type":"text","text":"capture list"}],"type":"emphasis"},{"text":" to explicitly control","type":"text"},{"text":" ","type":"text"},{"text":"how values are captured in a closure.","type":"text"}]},{"inlineContent":[{"text":"A capture list is written as a comma-separated list of expressions","type":"text"},{"type":"text","text":" "},{"type":"text","text":"surrounded by square brackets,"},{"type":"text","text":" "},{"type":"text","text":"before the list of parameters."},{"type":"text","text":" "},{"type":"text","text":"If you use a capture list, you must also use the "},{"type":"codeVoice","code":"in"},{"text":" keyword,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"even if you omit the parameter names, parameter types, and return type."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The entries in the capture list are initialized"},{"type":"text","text":" "},{"text":"when the closure is created.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For each entry in the capture list,"},{"type":"text","text":" "},{"text":"a constant is initialized","type":"text"},{"type":"text","text":" "},{"text":"to the value of the constant or variable that has the same name","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the surrounding scope."},{"text":" ","type":"text"},{"type":"text","text":"For example in the code below,"},{"type":"text","text":" "},{"code":"a","type":"codeVoice"},{"text":" is included in the capture list but ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":" is not,"},{"type":"text","text":" "},{"type":"text","text":"which gives them different behavior."}],"type":"paragraph"},{"type":"codeListing","code":["var a = 0","var b = 0","let closure = { [a] in"," print(a, b)","}","","a = 10","b = 10","closure()","\/\/ Prints \"0 10\""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"There are two different things named "},{"code":"a","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the variable in the surrounding scope"},{"type":"text","text":" "},{"type":"text","text":"and the constant in the closure’s scope,"},{"type":"text","text":" "},{"type":"text","text":"but only one variable named "},{"type":"codeVoice","code":"b"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" in the inner scope is initialized","type":"text"},{"type":"text","text":" "},{"text":"with the value of the ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" in the outer scope","type":"text"},{"type":"text","text":" "},{"text":"when the closure is created,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but their values aren’t connected in any special way."},{"type":"text","text":" "},{"text":"This means that a change to the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":" in the outer scope"},{"text":" ","type":"text"},{"text":"doesn’t affect the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" in the inner scope,","type":"text"},{"type":"text","text":" "},{"text":"nor does a change to ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" inside the closure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"affect the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" outside the closure."},{"type":"text","text":" "},{"text":"In contrast, there’s only one variable named ","type":"text"},{"type":"codeVoice","code":"b"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":" in the outer scope —"},{"type":"text","text":" "},{"text":"so changes from inside or outside the closure are visible in both places.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This distinction isn’t visible","type":"text"},{"type":"text","text":" "},{"text":"when the captured variable’s type has reference semantics.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"there are two things named ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" in the code below,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a variable in the outer scope and a constant in the inner scope,"},{"text":" ","type":"text"},{"type":"text","text":"but they both refer to the same object"},{"type":"text","text":" "},{"type":"text","text":"because of reference semantics."}]},{"syntax":"swift","code":["class SimpleClass {","    var value: Int = 0","}","var x = SimpleClass()","var y = SimpleClass()","let closure = { [x] in","    print(x.value, y.value)","}","","x.value = 10","y.value = 10","closure()","\/\/ Prints \"10 10\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If the type of the expression’s value is a class,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you can mark the expression in a capture list"},{"text":" ","type":"text"},{"type":"text","text":"with "},{"type":"codeVoice","code":"weak"},{"type":"text","text":" or "},{"code":"unowned","type":"codeVoice"},{"text":" to capture a weak or unowned reference","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to the expression’s value."}]},{"syntax":"swift","type":"codeListing","code":["myFunction { print(self.title) }                    \/\/ implicit strong capture","myFunction { [self] in print(self.title) }          \/\/ explicit strong capture","myFunction { [weak self] in print(self!.title) }    \/\/ weak capture","myFunction { [unowned self] in print(self.title) }  \/\/ unowned capture"]},{"type":"paragraph","inlineContent":[{"text":"You can also bind an arbitrary expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to a named value in a capture list."},{"type":"text","text":" "},{"type":"text","text":"The expression is evaluated when the closure is created,"},{"type":"text","text":" "},{"type":"text","text":"and the value is captured with the specified strength."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"code":["\/\/ Weak capture of \"self.parent\" as \"parent\"","myFunction { [weak parent = self.parent] in print(parent!.title) }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"For more information and examples of closure expressions,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions","type":"reference"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For more information and examples of capture lists,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Grammar of a closure expression","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"closure-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"{","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"closure-signature"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"statements","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"}","type":"codeVoice"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-signature"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-clause"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"async"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"throws-clause"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"function-result","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"in"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"closure-signature","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"capture-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"in"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" | "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-list","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"identifier-list","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-list","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"closure-parameter","type":"text"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"closure-parameter"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"closure-parameter-list","type":"text"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-name"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-name"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":"...","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"closure-parameter-name"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"capture-list","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"capture-list-items","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"]","type":"codeVoice"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-items"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-item"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture-list-item","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-list-items"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"capture-list-item","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"capture-specifier"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"text":"capture-list-item","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"capture-specifier","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"="}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"capture-list-item"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture-specifier"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-expression"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"capture-specifier","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"weak"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"unowned"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"unowned(safe)"}]},{"type":"text","text":" | "},{"inlineContent":[{"code":"unowned(unsafe)","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}],"type":"aside"},{"text":"Implicit Member Expression","type":"heading","level":3,"anchor":"Implicit-Member-Expression"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"implicit member expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"is an abbreviated way to access a member of a type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as an enumeration case or a type method,"},{"type":"text","text":" "},{"text":"in a context where type inference","type":"text"},{"text":" ","type":"text"},{"text":"can determine the implied type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"code":[".<#member name#>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example:"}]},{"code":["var x = MyEnumeration.someValue","x = .anotherValue"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the inferred type is an optional,"},{"type":"text","text":" "},{"text":"you can also use a member of the non-optional type","type":"text"},{"type":"text","text":" "},{"text":"in an implicit member expression.","type":"text"}]},{"type":"codeListing","code":["var someOptional: MyEnumeration? = .someValue"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Implicit member expressions can be followed by"},{"type":"text","text":" "},{"text":"a postfix operator or other postfix syntax listed in","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions","type":"reference"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This is called a ","type":"text"},{"inlineContent":[{"type":"text","text":"chained implicit member expression"}],"type":"emphasis"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Although it’s common for all of the chained postfix expressions"},{"type":"text","text":" "},{"type":"text","text":"to have the same type,"},{"type":"text","text":" "},{"text":"the only requirement is that the whole chained implicit member expression","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"needs to be convertible to the type implied by its context."},{"text":" ","type":"text"},{"text":"Specifically,","type":"text"},{"text":" ","type":"text"},{"text":"if the implied type is an optional","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you can use a value of the non-optional type,"},{"type":"text","text":" "},{"type":"text","text":"and if the implied type is a class type"},{"text":" ","type":"text"},{"text":"you can use a value of one of its subclasses.","type":"text"},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"code":["class SomeClass {","    static var shared = SomeClass()","    static var sharedSubclass = SomeSubclass()","    var a = AnotherClass()","}","class SomeSubclass: SomeClass { }","class AnotherClass {","    static var s = SomeClass()","    func f() -> SomeClass { return AnotherClass.s }","}","let x: SomeClass = .shared.a.f()","let y: SomeClass? = .shared","let z: SomeClass = .sharedSubclass"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above,"},{"text":" ","type":"text"},{"text":"the type of ","type":"text"},{"code":"x","type":"codeVoice"},{"type":"text","text":" matches the type implied by its context exactly,"},{"type":"text","text":" "},{"text":"the type of ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" is convertible from ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"SomeClass?"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and the type of ","type":"text"},{"type":"codeVoice","code":"z"},{"type":"text","text":" is convertible from "},{"type":"codeVoice","code":"SomeSubclass"},{"text":" to ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"implicit-member-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"implicit-member-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]}],"type":"paragraph"}],"type":"aside","name":"Grammar of an implicit member expression","style":"note"},{"level":3,"type":"heading","text":"Parenthesized Expression","anchor":"Parenthesized-Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"type":"text","text":"parenthesized expression"}],"type":"emphasis"},{"type":"text","text":" consists of"},{"type":"text","text":" "},{"type":"text","text":"an expression surrounded by parentheses."},{"text":" ","type":"text"},{"text":"You can use parentheses to specify the precedence of operations","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by explicitly grouping expressions."},{"type":"text","text":" "},{"text":"Grouping parentheses don’t change an expression’s type —","type":"text"},{"type":"text","text":" "},{"text":"for example, the type of ","type":"text"},{"code":"(1)","type":"codeVoice"},{"type":"text","text":" is simply "},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"parenthesized-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}],"type":"paragraph"}],"style":"note","type":"aside","name":"Grammar of a parenthesized expression"},{"text":"Tuple Expression","anchor":"Tuple-Expression","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"type":"text","text":"tuple expression"}],"type":"emphasis"},{"type":"text","text":" consists of"},{"text":" ","type":"text"},{"type":"text","text":"a comma-separated list of expressions surrounded by parentheses."},{"text":" ","type":"text"},{"type":"text","text":"Each expression can have an optional identifier before it,"},{"text":" ","type":"text"},{"text":"separated by a colon (","type":"text"},{"type":"codeVoice","code":":"},{"text":").","type":"text"},{"type":"text","text":" "},{"text":"It has the following form:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["(<#identifier 1#>: <#expression 1#>, <#identifier 2#>: <#expression 2#>, <#...#>)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each identifier in a tuple expression must be unique"},{"text":" ","type":"text"},{"type":"text","text":"within the scope of the tuple expression."},{"type":"text","text":" "},{"text":"In a nested tuple expression,","type":"text"},{"text":" ","type":"text"},{"text":"identifiers at the same level of nesting must be unique.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"(a: 10, a: 20)"},{"type":"text","text":" is invalid"},{"text":" ","type":"text"},{"text":"because the label ","type":"text"},{"type":"codeVoice","code":"a"},{"type":"text","text":" appears twice at the same level."},{"type":"text","text":" "},{"type":"text","text":"However, "},{"type":"codeVoice","code":"(a: 10, b: (a: 1, x: 2))"},{"text":" is valid —","type":"text"},{"type":"text","text":" "},{"text":"although ","type":"text"},{"code":"a","type":"codeVoice"},{"type":"text","text":" appears twice,"},{"text":" ","type":"text"},{"type":"text","text":"it appears once in the outer tuple and once in the inner tuple."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A tuple expression can contain zero expressions,"},{"text":" ","type":"text"},{"text":"or it can contain two or more expressions.","type":"text"},{"text":" ","type":"text"},{"text":"A single expression inside parentheses is a parenthesized expression.","type":"text"}]},{"type":"aside","content":[{"inlineContent":[{"type":"text","text":"Both an empty tuple expression and an empty tuple type"},{"type":"text","text":" "},{"text":"are written ","type":"text"},{"type":"codeVoice","code":"()"},{"text":" in Swift.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because "},{"code":"Void","type":"codeVoice"},{"text":" is a type alias for ","type":"text"},{"code":"()","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"you can use it to write an empty tuple type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However, like all type aliases, "},{"code":"Void","type":"codeVoice"},{"type":"text","text":" is always a type —"},{"type":"text","text":" "},{"type":"text","text":"you can’t use it to write an empty tuple expression."}],"type":"paragraph"}],"name":"Note","style":"note"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"tuple-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"tuple-element","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-element-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"tuple-element-list"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"tuple-element","type":"text"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-element"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"tuple-element-list","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-element"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"}]}],"style":"note","name":"Grammar of a tuple expression"},{"type":"heading","level":3,"anchor":"Wildcard-Expression","text":"Wildcard Expression"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"wildcard expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"is used to explicitly ignore a value during an assignment.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, in the following assignment"},{"text":" ","type":"text"},{"type":"text","text":"10 is assigned to "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and 20 is ignored:"}]},{"type":"codeListing","syntax":"swift","code":["(x, _) = (10, 20)","\/\/ x is 10, and 20 is ignored"]},{"type":"aside","name":"Grammar of a wildcard expression","style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"wildcard-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"_"}]}]}]},{"type":"heading","level":3,"anchor":"Macro-Expansion-Expression","text":"Macro-Expansion Expression"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"macro-expansion expression"}],"type":"emphasis"},{"type":"text","text":" consists of a macro name"},{"type":"text","text":" "},{"type":"text","text":"followed by a comma-separated list of the macro’s arguments in parentheses."},{"text":" ","type":"text"},{"type":"text","text":"The macro is expanded at compile time."},{"type":"text","text":" "},{"type":"text","text":"Macro-expansion expressions have the following form:"}]},{"syntax":"swift","type":"codeListing","code":["<#macro name#>(<#macro argument 1#>, <#macro argument 2#>)"]},{"inlineContent":[{"type":"text","text":"A macro-expansion expression omits the parentheses after the macro’s name"},{"type":"text","text":" "},{"text":"if the macro doesn’t take any arguments.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A macro-expansion expression can’t appear as the default value for a parameter,"},{"type":"text","text":" "},{"type":"text","text":"except the "},{"type":"reference","isActive":true,"overridingTitle":"file()","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","overridingTitleInlineContent":[{"code":"file()","type":"codeVoice"}]},{"type":"text","text":" and "},{"overridingTitleInlineContent":[{"code":"line()","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()","type":"reference","isActive":true,"overridingTitle":"line()"},{"type":"text","text":" macros from the Swift standard library."},{"type":"text","text":" "},{"type":"text","text":"When used as the default value of a function or method parameter,"},{"text":" ","type":"text"},{"text":"these macros are evaluated using the source code location of the call site,","type":"text"},{"text":" ","type":"text"},{"text":"not the location where they appear in a function definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You use macro expressions to call freestanding macros."},{"type":"text","text":" "},{"text":"To call an attached macro,","type":"text"},{"text":" ","type":"text"},{"text":"use the custom attribute syntax described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Both freestanding and attached macros expand as follows:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift parses the source code"},{"text":" ","type":"text"},{"type":"text","text":"to produce an abstract syntax tree (AST)."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The macro implementation receives AST nodes as its input"},{"type":"text","text":" "},{"text":"and performs the transformations needed by that macro.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The transformed AST nodes that the macro implementation produced"},{"type":"text","text":" "},{"type":"text","text":"are added to the original AST."}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"The expansion of each macro is independent and self-contained.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, as a performance optimization,"},{"type":"text","text":" "},{"type":"text","text":"Swift might start an external process that implements the macro"},{"text":" ","type":"text"},{"type":"text","text":"and reuse the same process to expand multiple macros."},{"type":"text","text":" "},{"type":"text","text":"When you implement a macro,"},{"text":" ","type":"text"},{"text":"that code must not depend on what macros your code previously expanded,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or on any other external state like the current time."}]},{"inlineContent":[{"type":"text","text":"For nested macros and attached macros that have multiple roles,"},{"type":"text","text":" "},{"text":"the expansion process repeats.","type":"text"},{"type":"text","text":" "},{"text":"Nested macro-expansion expressions expand from the outside in.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, in the code below"},{"type":"text","text":" "},{"code":"outerMacro(_:)","type":"codeVoice"},{"text":" expands first and the unexpanded call to ","type":"text"},{"type":"codeVoice","code":"innerMacro(_:)"},{"type":"text","text":" "},{"text":"appears in the abstract syntax tree","type":"text"},{"text":" ","type":"text"},{"text":"that ","type":"text"},{"code":"outerMacro(_:)","type":"codeVoice"},{"text":" receives as its input.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["#outerMacro(12, #innerMacro(34), \"some text\")"],"syntax":"swift"},{"inlineContent":[{"text":"An attached macro that has multiple roles expands once for each role.","type":"text"},{"type":"text","text":" "},{"text":"Each expansion receives the same, original, AST as its input.","type":"text"},{"type":"text","text":" "},{"text":"Swift forms the overall expansion","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by collecting all of the generated AST nodes"},{"type":"text","text":" "},{"text":"and putting them in their corresponding places in the AST.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an overview of macros in Swift, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Macros"},{"type":"text","text":"."}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"macro-expansion-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"#","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic-argument-clause"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"function-call-argument-clause","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"trailing-closures"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"}]}],"name":"Grammar of a macro-expansion expression"},{"type":"heading","text":"Key-Path Expression","anchor":"Key-Path-Expression","level":3},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path expression"}]},{"type":"text","text":" "},{"type":"text","text":"refers to a property or subscript of a type."},{"text":" ","type":"text"},{"type":"text","text":"You use key-path expressions"},{"text":" ","type":"text"},{"type":"text","text":"in dynamic programming tasks,"},{"text":" ","type":"text"},{"type":"text","text":"such as key-value observing."},{"type":"text","text":" "},{"type":"text","text":"They have the following form:"}],"type":"paragraph"},{"code":["\\<#type name#>.<#path#>"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type name"}]},{"text":" is the name of a concrete type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"including any generic parameters,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"code":"String","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"[Int]"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Set<Int>"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"path","type":"text"}]},{"text":" consists of","type":"text"},{"type":"text","text":" "},{"text":"property names, subscripts, optional-chaining expressions,","type":"text"},{"text":" ","type":"text"},{"text":"and forced unwrapping expressions.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Each of these key-path components"},{"type":"text","text":" "},{"text":"can be repeated as many times as needed,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in any order."}],"type":"paragraph"},{"inlineContent":[{"text":"At compile time, a key-path expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is replaced by an instance"},{"text":" ","type":"text"},{"type":"text","text":"of the "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","isActive":true},{"text":" class.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To access a value using a key path,"},{"type":"text","text":" "},{"type":"text","text":"pass the key path to the "},{"code":"subscript(keyPath:)","type":"codeVoice"},{"text":" subscript,","type":"text"},{"type":"text","text":" "},{"text":"which is available on all types.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","code":["struct SomeStructure {","    var someValue: Int","}","","let s = SomeStructure(someValue: 12)","let pathToProperty = \\SomeStructure.someValue","","let value = s[keyPath: pathToProperty]","\/\/ value is 12"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type name"}]},{"type":"text","text":" can be omitted"},{"text":" ","type":"text"},{"text":"in contexts where type inference","type":"text"},{"type":"text","text":" "},{"text":"can determine the implied type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The following code uses "},{"code":"\\.someProperty","type":"codeVoice"},{"type":"text","text":" "},{"text":"instead of ","type":"text"},{"code":"\\SomeClass.someProperty","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class SomeClass: NSObject {","    @objc dynamic var someProperty: Int","    init(someProperty: Int) {","        self.someProperty = someProperty","    }","}","","let c = SomeClass(someProperty: 10)","c.observe(\\.someProperty) { object, change in","    \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"path","type":"text"}]},{"type":"text","text":" can refer to "},{"code":"self","type":"codeVoice"},{"text":" to create the identity key path (","type":"text"},{"code":"\\.self","type":"codeVoice"},{"text":").","type":"text"},{"type":"text","text":" "},{"text":"The identity key path refers to a whole instance,","type":"text"},{"text":" ","type":"text"},{"text":"so you can use it to access and change all of the data stored in a variable","type":"text"},{"text":" ","type":"text"},{"text":"in a single step.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"code":["var compoundValue = (a: 1, b: 2)","\/\/ Equivalent to compoundValue = (a: 10, b: 20)","compoundValue[keyPath: \\.self] = (a: 10, b: 20)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"path","type":"text"}],"type":"emphasis"},{"text":" can contain multiple property names,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"separated by periods,"},{"type":"text","text":" "},{"type":"text","text":"to refer to a property of a property’s value."},{"type":"text","text":" "},{"text":"This code uses the key path expression","type":"text"},{"type":"text","text":" "},{"code":"\\OuterStructure.outer.someValue","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"to access the "},{"type":"codeVoice","code":"someValue"},{"text":" property","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of the "},{"code":"OuterStructure","type":"codeVoice"},{"type":"text","text":" type’s "},{"code":"outer","type":"codeVoice"},{"text":" property:","type":"text"}]},{"code":["struct OuterStructure {","    var outer: SomeStructure","    init(someValue: Int) {","        self.outer = SomeStructure(someValue: someValue)","    }","}","","let nested = OuterStructure(someValue: 24)","let nestedKeyPath = \\OuterStructure.outer.someValue","","let nestedValue = nested[keyPath: nestedKeyPath]","\/\/ nestedValue is 24"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"path","type":"text"}]},{"type":"text","text":" can include subscripts using brackets,"},{"type":"text","text":" "},{"type":"text","text":"as long as the subscript’s parameter type conforms to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"text":"This example uses a subscript in a key path","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to access the second element of an array:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let greetings = [\"hello\", \"hola\", \"bonjour\", \"안녕\"]","let myGreeting = greetings[keyPath: \\[String].[1]]","\/\/ myGreeting is 'hola'"]},{"type":"paragraph","inlineContent":[{"text":"The value used in a subscript can be a named value or a literal.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Values are captured in key paths using value semantics."},{"type":"text","text":" "},{"text":"The following code uses the variable ","type":"text"},{"type":"codeVoice","code":"index"},{"type":"text","text":" "},{"type":"text","text":"in both a key-path expression and in a closure to access"},{"type":"text","text":" "},{"text":"the third element of the ","type":"text"},{"code":"greetings","type":"codeVoice"},{"text":" array.","type":"text"},{"type":"text","text":" "},{"text":"When ","type":"text"},{"type":"codeVoice","code":"index"},{"type":"text","text":" is modified,"},{"text":" ","type":"text"},{"type":"text","text":"the key-path expression still references the third element,"},{"text":" ","type":"text"},{"text":"while the closure uses the new index.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var index = 2","let path = \\[String].[index]","let fn: ([String]) -> String = { strings in strings[index] }","","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","print(fn(greetings))","\/\/ Prints \"bonjour\"","","\/\/ Setting 'index' to a new value doesn't affect 'path'","index += 1","print(greetings[keyPath: path])","\/\/ Prints \"bonjour\"","","\/\/ Because 'fn' closes over 'index', it uses the new value","print(fn(greetings))","\/\/ Prints \"안녕\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"path","type":"text"}],"type":"emphasis"},{"text":" can use optional chaining and forced unwrapping.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This code uses optional chaining in a key path"},{"type":"text","text":" "},{"type":"text","text":"to access a property of an optional string:"}]},{"type":"codeListing","syntax":"swift","code":["let firstGreeting: String? = greetings.first","print(firstGreeting?.count as Any)","\/\/ Prints \"Optional(5)\"","","\/\/ Do the same thing using a key path.","let count = greetings[keyPath: \\[String].first?.count]","print(count as Any)","\/\/ Prints \"Optional(5)\""]},{"inlineContent":[{"type":"text","text":"You can mix and match components of key paths to access values"},{"type":"text","text":" "},{"text":"that are deeply nested within a type.","type":"text"},{"text":" ","type":"text"},{"text":"The following code accesses different values and properties","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of a dictionary of arrays"},{"type":"text","text":" "},{"type":"text","text":"by using key-path expressions"},{"text":" ","type":"text"},{"type":"text","text":"that combine these components."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let interestingNumbers = [\"prime\": [2, 3, 5, 7, 11, 13, 17],","                          \"triangular\": [1, 3, 6, 10, 15, 21, 28],","                          \"hexagonal\": [1, 6, 15, 28, 45, 66, 91]]","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]] as Any)","\/\/ Prints \"Optional([2, 3, 5, 7, 11, 13, 17])\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"prime\"]![0]])","\/\/ Prints \"2\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count])","\/\/ Prints \"7\"","print(interestingNumbers[keyPath: \\[String: [Int]].[\"hexagonal\"]!.count.bitWidth])","\/\/ Prints \"64\""]},{"inlineContent":[{"type":"text","text":"You can use a key path expression"},{"text":" ","type":"text"},{"text":"in contexts where you would normally provide a function or closure.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Specifically,"},{"text":" ","type":"text"},{"text":"you can use a key path expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whose root type is "},{"type":"codeVoice","code":"SomeType"},{"type":"text","text":" "},{"type":"text","text":"and whose path produces a value of type "},{"code":"Value","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"instead of a function or closure of type "},{"type":"codeVoice","code":"(SomeType) -> Value"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Task {","    var description: String","    var completed: Bool","}","var toDoList = [","    Task(description: \"Practice ping-pong.\", completed: false),","    Task(description: \"Buy a pirate costume.\", completed: true),","    Task(description: \"Visit Boston in the Fall.\", completed: false),","]","","\/\/ Both approaches below are equivalent.","let descriptions = toDoList.filter(\\.completed).map(\\.description)","let descriptions2 = toDoList.filter { $0.completed }.map { $0.description }"]},{"type":"paragraph","inlineContent":[{"text":"Any side effects of a key path expression","type":"text"},{"type":"text","text":" "},{"text":"are evaluated only at the point where the expression is evaluated.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"if you make a function call inside a subscript in a key path expression,","type":"text"},{"type":"text","text":" "},{"text":"the function is called only once as part of evaluating the expression,","type":"text"},{"text":" ","type":"text"},{"text":"not every time the key path is used.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func makeIndex() -> Int {","    print(\"Made an index\")","    return 0","}","\/\/ The line below calls makeIndex().","let taskKeyPath = \\[Task][makeIndex()]","\/\/ Prints \"Made an index\"","","\/\/ Using taskKeyPath doesn't call makeIndex() again.","let someTask = toDoList[keyPath: taskKeyPath]"]},{"inlineContent":[{"type":"text","text":"For more information about using key paths"},{"type":"text","text":" "},{"text":"in code that interacts with Objective-C APIs,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"For information about key-value coding and key-value observing,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"name":"Grammar of a key-path expression","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"key-path-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"\\"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-components"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"key-path-components","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"key-path-component","type":"text"}]},{"text":" | ","type":"text"},{"inlineContent":[{"text":"key-path-component","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":".","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-components"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-component"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-postfixes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"text","text":"key-path-postfixes"}],"type":"emphasis"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-postfixes"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"key-path-postfix"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"key-path-postfixes","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"key-path-postfix"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"code":"!","type":"codeVoice"}]},{"type":"text","text":" | "},{"inlineContent":[{"type":"codeVoice","code":"self"}],"type":"strong"},{"text":" | ","type":"text"},{"inlineContent":[{"code":"[","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-call-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"]"}],"type":"strong"}],"type":"paragraph"}],"style":"note"},{"anchor":"Selector-Expression","type":"heading","text":"Selector Expression","level":3},{"inlineContent":[{"type":"text","text":"A selector expression lets you access the selector"},{"text":" ","type":"text"},{"type":"text","text":"used to refer to a method or to a property’s"},{"type":"text","text":" "},{"type":"text","text":"getter or setter in Objective-C."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"code":["#selector(<#method name#>)","#selector(getter: <#property name#>)","#selector(setter: <#property name#>)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"method name"}],"type":"emphasis"},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" must be a reference to a method or a property"},{"text":" ","type":"text"},{"text":"that’s available in the Objective-C runtime.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The value of a selector expression is an instance of the "},{"code":"Selector","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"text":"For example:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class SomeClass: NSObject {","    @objc let property: String","","    @objc(doSomethingWithInt:)","    func doSomething(_ x: Int) { }","","    init(property: String) {","        self.property = property","    }","}","let selectorForMethod = #selector(SomeClass.doSomething(_:))","let selectorForPropertyGetter = #selector(getter: SomeClass.property)"]},{"type":"paragraph","inlineContent":[{"text":"When creating a selector for a property’s getter,","type":"text"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"inlineContent":[{"type":"text","text":"property name"}],"type":"emphasis"},{"text":" can be a reference to a variable or constant property.","type":"text"},{"type":"text","text":" "},{"text":"In contrast, when creating a selector for a property’s setter,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"inlineContent":[{"text":"property name","type":"text"}],"type":"emphasis"},{"text":" must be a reference to a variable property only.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"method name","type":"text"}],"type":"emphasis"},{"type":"text","text":" can contain parentheses for grouping,"},{"type":"text","text":" "},{"text":"as well the ","type":"text"},{"type":"codeVoice","code":"as"},{"text":" operator to disambiguate between methods that share a name","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but have different type signatures."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["extension SomeClass {","    @objc(doSomethingWithString:)","    func doSomething(_ x: String) { }","}","let anotherSelector = #selector(SomeClass.doSomething(_:) as (SomeClass) -> (String) -> Void)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Because a selector is created at compile time, not at runtime,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the compiler can check that a method or property exists"},{"type":"text","text":" "},{"text":"and that they’re exposed to the Objective-C runtime.","type":"text"}]},{"type":"aside","name":"Note","content":[{"inlineContent":[{"text":"Although the ","type":"text"},{"inlineContent":[{"text":"method name","type":"text"}],"type":"emphasis"},{"type":"text","text":" and the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"property name"}]},{"type":"text","text":" are expressions,"},{"type":"text","text":" "},{"text":"they’re never evaluated.","type":"text"}],"type":"paragraph"}],"style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about using selectors"},{"text":" ","type":"text"},{"type":"text","text":"in Swift code that interacts with Objective-C APIs,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","overridingTitle":"Using Objective-C Runtime Features in Swift","overridingTitleInlineContent":[{"text":"Using Objective-C Runtime Features in Swift","type":"text"}],"type":"reference","isActive":true},{"text":".","type":"text"}]},{"style":"note","name":"Grammar of a selector expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"selector-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#selector"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"(","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"selector-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#selector"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"getter:"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"selector-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"code":"#selector","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"setter:","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}],"type":"aside"},{"level":3,"text":"Key-Path String Expression","type":"heading","anchor":"Key-Path-String-Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A key-path string expression lets you access the string"},{"text":" ","type":"text"},{"type":"text","text":"used to refer to a property in Objective-C,"},{"type":"text","text":" "},{"type":"text","text":"for use in key-value coding and key-value observing APIs."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"type":"codeListing","syntax":"swift","code":["#keyPath(<#property name#>)"]},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"property name"}],"type":"emphasis"},{"type":"text","text":" must be a reference to a property"},{"type":"text","text":" "},{"type":"text","text":"that’s available in the Objective-C runtime."},{"type":"text","text":" "},{"text":"At compile time, the key-path string expression is replaced by a string literal.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class SomeClass: NSObject {","    @objc var someProperty: Int","    init(someProperty: Int) {","       self.someProperty = someProperty","    }","}","","let c = SomeClass(someProperty: 12)","let keyPath = #keyPath(SomeClass.someProperty)","","if let value = c.value(forKey: keyPath) {","    print(value)","}","\/\/ Prints \"12\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you use a key-path string expression within a class,"},{"type":"text","text":" "},{"type":"text","text":"you can refer to a property of that class"},{"type":"text","text":" "},{"type":"text","text":"by writing just the property name, without the class name."}]},{"code":["extension SomeClass {","    func getSomeKeyPath() -> String {","        return #keyPath(someProperty)","    }","}","print(keyPath == c.getSomeKeyPath())","\/\/ Prints \"true\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Because the key path string is created at compile time, not at runtime,","type":"text"},{"type":"text","text":" "},{"text":"the compiler can check that the property exists","type":"text"},{"text":" ","type":"text"},{"text":"and that the property is exposed to the Objective-C runtime.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For more information about using key paths","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in Swift code that interacts with Objective-C APIs,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"type":"reference","overridingTitle":"Using Objective-C Runtime Features in Swift","overridingTitleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For information about key-value coding and key-value observing,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","overridingTitle":"Key-Value Coding Programming Guide","overridingTitleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}],"type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"and "},{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","type":"reference","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"Key-Value Observing Programming Guide"}],"overridingTitle":"Key-Value Observing Programming Guide"},{"type":"text","text":"."}]},{"type":"aside","name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Although the ","type":"text"},{"inlineContent":[{"text":"property name","type":"text"}],"type":"emphasis"},{"text":" is an expression, it’s never evaluated.","type":"text"}]}]},{"style":"note","name":"Grammar of a key-path string expression","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"key-path-string-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"#keyPath"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}],"type":"aside"},{"text":"Postfix Expressions","level":2,"type":"heading","anchor":"Postfix-Expressions"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Postfix expressions","type":"text"}]},{"type":"text","text":" are formed"},{"type":"text","text":" "},{"text":"by applying a postfix operator or other postfix syntax","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to an expression."},{"type":"text","text":" "},{"type":"text","text":"Syntactically, every primary expression is also a postfix expression."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the behavior of these operators,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"text":" and ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"For information about the operators provided by the Swift standard library,","type":"text"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations","overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}]},{"text":".","type":"text"}]},{"name":"Grammar of a postfix expression","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"primary-expression"}]},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-operator"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-expression"}]},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"initializer-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"explicit-member-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"postfix-self-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"subscript-expression"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"forced-value-expression","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"optional-chaining-expression","type":"text"}]}]}],"style":"note"},{"level":3,"anchor":"Function-Call-Expression","type":"heading","text":"Function Call Expression"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"function call expression","type":"text"}]},{"type":"text","text":" consists of a function name"},{"type":"text","text":" "},{"text":"followed by a comma-separated list of the function’s arguments in parentheses.","type":"text"},{"text":" ","type":"text"},{"text":"Function call expressions have the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["<#function name#>(<#argument value 1#>, <#argument value 2#>)"]},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function name"}]},{"type":"text","text":" can be any expression whose value is of a function type."}],"type":"paragraph"},{"inlineContent":[{"text":"If the function definition includes names for its parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the function call must include names before its argument values,"},{"type":"text","text":" "},{"type":"text","text":"separated by a colon ("},{"code":":","type":"codeVoice"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"This kind of function call expression has the following form:"}],"type":"paragraph"},{"type":"codeListing","code":["<#function name#>(<#argument name 1#>: <#argument value 1#>, <#argument name 2#>: <#argument value 2#>)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"A function call expression can include trailing closures","type":"text"},{"type":"text","text":" "},{"text":"in the form of closure expressions immediately after the closing parenthesis.","type":"text"},{"text":" ","type":"text"},{"text":"The trailing closures are understood as arguments to the function,","type":"text"},{"type":"text","text":" "},{"text":"added after the last parenthesized argument.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The first closure expression is unlabeled;"},{"type":"text","text":" "},{"text":"any additional closure expressions are preceded by their argument labels.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The example below shows the equivalent version of function calls"},{"text":" ","type":"text"},{"text":"that do and don’t use trailing closure syntax:","type":"text"}]},{"code":["\/\/ someFunction takes an integer and a closure as its arguments","someFunction(x: x, f: { $0 == 13 })","someFunction(x: x) { $0 == 13 }","","\/\/ anotherFunction takes an integer and two closures as its arguments","anotherFunction(x: x, f: { $0 == 13 }, g: { print(99) })","anotherFunction(x: x) { $0 == 13 } g: { print(99) }"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If the trailing closure is the function’s only argument,"},{"text":" ","type":"text"},{"type":"text","text":"you can omit the parentheses."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ someMethod takes a closure as its only argument","myData.someMethod() { $0 == 13 }","myData.someMethod { $0 == 13 }"]},{"inlineContent":[{"text":"To include the trailing closures in the arguments,","type":"text"},{"type":"text","text":" "},{"text":"the compiler examines the function’s parameters from left to right as follows:","type":"text"}],"type":"paragraph"},{"header":"row","type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Trailing Closure"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Parameter"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Action"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped."}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled"}]}],[{"inlineContent":[{"type":"text","text":"Unlabeled"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"The parameter is skipped.","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Labeled or unlabeled"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped."}]}]]]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The trailing closure is passed as the argument for the parameter that it matches."},{"type":"text","text":" "},{"text":"Parameters that were skipped during the scanning process","type":"text"},{"type":"text","text":" "},{"type":"text","text":"don’t have an argument passed to them —"},{"type":"text","text":" "},{"text":"for example, they can use a default parameter.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"After finding a match, scanning continues"},{"text":" ","type":"text"},{"text":"with the next trailing closure and the next parameter.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"At the end of the matching process,"},{"text":" ","type":"text"},{"type":"text","text":"all trailing closures must have a match."}]},{"inlineContent":[{"text":"A parameter ","type":"text"},{"inlineContent":[{"type":"text","text":"structurally resembles"}],"type":"emphasis"},{"type":"text","text":" a function type"},{"type":"text","text":" "},{"type":"text","text":"if the parameter isn’t an in-out parameter,"},{"text":" ","type":"text"},{"type":"text","text":"and the parameter is one of the following:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"code":"(Bool) -> Int","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An autoclosure parameter"},{"text":" ","type":"text"},{"type":"text","text":"whose wrapped expression’s type is a function type,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"type":"codeVoice","code":"@autoclosure () -> ((Bool) -> Int)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A variadic parameter"},{"type":"text","text":" "},{"text":"whose array element type is a function type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"like "},{"code":"((Bool) -> Int)...","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"A parameter whose type is wrapped in one or more layers of optional,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"like "},{"type":"codeVoice","code":"Optional<(Bool) -> Int>"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A parameter whose type combines these allowed types,"},{"type":"text","text":" "},{"type":"text","text":"like "},{"code":"(Optional<(Bool) -> Int>)...","type":"codeVoice"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"When a trailing closure is matched to a parameter","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whose type structurally resembles a function type, but isn’t a function,"},{"type":"text","text":" "},{"type":"text","text":"the closure is wrapped as needed."},{"type":"text","text":" "},{"type":"text","text":"For example, if the parameter’s type is an optional type,"},{"type":"text","text":" "},{"type":"text","text":"the closure is wrapped in "},{"type":"codeVoice","code":"Optional"},{"text":" automatically.","type":"text"}]},{"inlineContent":[{"text":"To ease migration of code from versions of Swift prior to 5.3 —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which performed this matching from right to left —"},{"text":" ","type":"text"},{"text":"the compiler checks both the left-to-right and right-to-left orderings.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the scan directions produce different results,"},{"text":" ","type":"text"},{"type":"text","text":"the old right-to-left ordering is used"},{"type":"text","text":" "},{"type":"text","text":"and the compiler generates a warning."},{"type":"text","text":" "},{"type":"text","text":"A future version of Swift will always use the left-to-right ordering."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["typealias Callback = (Int) -> Int","func someFunction(firstClosure: Callback? = nil,","                secondClosure: Callback? = nil) {","    let first = firstClosure?(10)","    let second = secondClosure?(20)","    print(first ?? \"-\", second ?? \"-\")","}","","someFunction()  \/\/ Prints \"- -\"","someFunction { return $0 + 100 }  \/\/ Ambiguous","someFunction { return $0 } secondClosure: { return $0 }  \/\/ Prints \"10 20\""]},{"inlineContent":[{"type":"text","text":"In the example above,"},{"text":" ","type":"text"},{"text":"the function call marked “Ambiguous”","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"prints “- 120” and produces a compiler warning on Swift 5.3."},{"text":" ","type":"text"},{"text":"A future version of Swift will print “110 -”.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A class, structure, or enumeration type"},{"text":" ","type":"text"},{"text":"can enable syntactic sugar for function call syntax","type":"text"},{"text":" ","type":"text"},{"text":"by declaring one of several methods,","type":"text"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names","isActive":true},{"type":"text","text":"."}]},{"anchor":"Implicit-Conversion-to-a-Pointer-Type","type":"heading","text":"Implicit Conversion to a Pointer Type","level":4},{"inlineContent":[{"text":"In a function call expression,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"if the argument and parameter have a different type,"},{"text":" ","type":"text"},{"type":"text","text":"the compiler tries to make their types match"},{"type":"text","text":" "},{"type":"text","text":"by applying one of the implicit conversions in the following list:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"inout SomeType"},{"text":" can become","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"UnsafeMutablePointer<SomeType>"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"inout Array<SomeType>","type":"codeVoice"},{"type":"text","text":" can become"},{"text":" ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<SomeType>"},{"type":"text","text":" or "},{"code":"UnsafeMutablePointer<SomeType>","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Array<SomeType>"},{"text":" can become ","type":"text"},{"code":"UnsafePointer<SomeType>","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"},{"text":" can become ","type":"text"},{"code":"UnsafePointer<CChar>","type":"codeVoice"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following two function calls are equivalent:"}]},{"syntax":"swift","code":["func unsafeFunction(pointer: UnsafePointer<Int>) {","    \/\/ ...","}","var myNumber = 1234","","unsafeFunction(pointer: &myNumber)","withUnsafePointer(to: myNumber) { unsafeFunction(pointer: $0) }"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"A pointer that’s created by these implicit conversions","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is valid only for the duration of the function call."},{"text":" ","type":"text"},{"text":"To avoid undefined behavior,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"ensure that your code"},{"text":" ","type":"text"},{"text":"never persists the pointer after the function call ends.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When implicitly converting an array to an unsafe pointer,"},{"text":" ","type":"text"},{"type":"text","text":"Swift ensures that the array’s storage is contiguous"},{"text":" ","type":"text"},{"text":"by converting or copying the array as needed.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example, you can use this syntax"},{"type":"text","text":" "},{"type":"text","text":"with an array that was bridged to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" "},{"type":"text","text":"from an "},{"code":"NSArray","type":"codeVoice"},{"text":" subclass that makes no API contract about its storage.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If you need to guarantee that the array’s storage is already contiguous,"},{"text":" ","type":"text"},{"text":"so the implicit conversion never needs to do this work,","type":"text"},{"text":" ","type":"text"},{"text":"use ","type":"text"},{"type":"codeVoice","code":"ContiguousArray"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"Array"},{"text":".","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"Using ","type":"text"},{"type":"codeVoice","code":"&"},{"text":" instead of an explicit function like ","type":"text"},{"code":"withUnsafePointer(to:)","type":"codeVoice"},{"text":" ","type":"text"},{"text":"can help make calls to low-level C functions more readable,","type":"text"},{"type":"text","text":" "},{"text":"especially when the function takes several pointer arguments.","type":"text"},{"type":"text","text":" "},{"text":"However, when calling functions from other Swift code,","type":"text"},{"type":"text","text":" "},{"text":"avoid using ","type":"text"},{"code":"&","type":"codeVoice"},{"text":" instead of using the unsafe APIs explicitly.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Grammar of a function call expression","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"function-call-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-call-argument-clause"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"function-call-expression","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"function-call-argument-clause","type":"text"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"trailing-closures","type":"text"}]}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"function-call-argument-clause"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-list"}]},{"type":"text","text":" "},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-list"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"function-call-argument"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"function-call-argument"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":",","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"function-call-argument-list"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"text":"function-call-argument","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"trailing-closures"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"closure-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"labeled-trailing-closures","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"text":" ","type":"text"},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"labeled-trailing-closures"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"labeled-trailing-closure"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"labeled-trailing-closures"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"type":"emphasis","inlineContent":[{"type":"text","text":"labeled-trailing-closure"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"closure-expression","type":"text"}]}]}],"type":"aside"},{"level":3,"text":"Initializer Expression","type":"heading","anchor":"Initializer-Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"initializer expression"}],"type":"emphasis"},{"type":"text","text":" provides access"},{"type":"text","text":" "},{"type":"text","text":"to a type’s initializer."},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}]},{"code":["<#expression#>.init(<#initializer arguments#>)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"You use the initializer expression in a function call expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to initialize a new instance of a type."},{"type":"text","text":" "},{"type":"text","text":"You also use an initializer expression"},{"text":" ","type":"text"},{"text":"to delegate to the initializer of a superclass.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class SomeSubClass: SomeSuperClass {","    override init() {","        \/\/ subclass initialization goes here","        super.init()","    }","}"]},{"inlineContent":[{"text":"Like a function, an initializer can be used as a value.","type":"text"},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Type annotation is required because String has multiple initializers.","let initializer: (Int) -> String = String.init","let oneTwoThree = [1, 2, 3].map(initializer).reduce(\"\", +)","print(oneTwoThree)","\/\/ Prints \"123\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"If you specify a type by name,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can access the type’s initializer without using an initializer expression."},{"type":"text","text":" "},{"text":"In all other cases, you must use an initializer expression.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let s1 = SomeType.init(data: 3)  \/\/ Valid","let s2 = SomeType(data: 1)       \/\/ Also valid","","let s3 = type(of: someValue).init(data: 7)  \/\/ Valid","let s4 = type(of: someValue)(data: 5)       \/\/ Error"],"type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"initializer-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"init","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"initializer-expression"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"init"}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"argument-names"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"code":")","type":"codeVoice"}],"type":"strong"}]}],"type":"aside","style":"note","name":"Grammar of an initializer expression"},{"type":"heading","level":3,"anchor":"Explicit-Member-Expression","text":"Explicit Member Expression"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"explicit member expression"}],"type":"emphasis"},{"type":"text","text":" allows access"},{"type":"text","text":" "},{"text":"to the members of a named type, a tuple, or a module.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It consists of a period ("},{"code":".","type":"codeVoice"},{"text":") between the item","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the identifier of its member."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["<#expression#>.<#member name#>"]},{"inlineContent":[{"type":"text","text":"The members of a named type are named"},{"text":" ","type":"text"},{"type":"text","text":"as part of the type’s declaration or extension."},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class SomeClass {","    var someProperty = 42","}","let c = SomeClass()","let y = c.someProperty  \/\/ Member access"]},{"inlineContent":[{"text":"The members of a tuple","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"are implicitly named using integers in the order they appear,"},{"type":"text","text":" "},{"text":"starting from zero.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var t = (10, 20, 30)","t.0 = t.1","\/\/ Now t is (20, 20, 30)"]},{"inlineContent":[{"type":"text","text":"The members of a module access"},{"text":" ","type":"text"},{"text":"the top-level declarations of that module.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Types declared with the ","type":"text"},{"code":"dynamicMemberLookup","type":"codeVoice"},{"text":" attribute","type":"text"},{"type":"text","text":" "},{"type":"text","text":"include members that are looked up at runtime,"},{"type":"text","text":" "},{"text":"as described in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To distinguish between methods or initializers"},{"type":"text","text":" "},{"type":"text","text":"whose names differ only by the names of their arguments,"},{"type":"text","text":" "},{"text":"include the argument names in parentheses,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with each argument name followed by a colon ("},{"code":":","type":"codeVoice"},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Write an underscore ("},{"code":"_","type":"codeVoice"},{"type":"text","text":") for an argument with no name."},{"text":" ","type":"text"},{"text":"To distinguish between overloaded methods,","type":"text"},{"type":"text","text":" "},{"text":"use a type annotation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"syntax":"swift","type":"codeListing","code":["class SomeClass {","    func someMethod(x: Int, y: Int) {}","    func someMethod(x: Int, z: Int) {}","    func overloadedMethod(x: Int, y: Int) {}","    func overloadedMethod(x: Int, y: Bool) {}","}","let instance = SomeClass()","","let a = instance.someMethod              \/\/ Ambiguous","let b = instance.someMethod(x:y:)        \/\/ Unambiguous","","let d = instance.overloadedMethod        \/\/ Ambiguous","let d = instance.overloadedMethod(x:y:)  \/\/ Still ambiguous","let d: (Int, Bool) -> Void  = instance.overloadedMethod(x:y:)  \/\/ Unambiguous"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a period appears at the beginning of a line,"},{"type":"text","text":" "},{"type":"text","text":"it’s understood as part of an explicit member expression,"},{"text":" ","type":"text"},{"text":"not as an implicit member expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the following listing shows chained method calls"},{"type":"text","text":" "},{"type":"text","text":"split over several lines:"}]},{"type":"codeListing","syntax":"swift","code":["let x = [10, 3, 20, 15, 4]","    .sorted()","    .filter { $0 > 5 }","    .map { $0 * 100 }"]},{"type":"paragraph","inlineContent":[{"text":"You can combine this multiline chained syntax","type":"text"},{"text":" ","type":"text"},{"text":"with compiler control statements","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to control when each method is called."},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"type":"text","text":"the following code uses a different filtering rule on iOS:"}]},{"code":["let numbers = [10, 20, 33, 43, 50]","#if os(iOS)","    .filter { $0 < 40 }","#else","    .filter { $0 > 25 }","#endif"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Between ","type":"text"},{"code":"#if","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"#endif"},{"text":", and other compilation directives,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the conditional compilation block can contain"},{"type":"text","text":" "},{"text":"an implicit member expression","type":"text"},{"type":"text","text":" "},{"text":"followed by zero or more postfixes,","type":"text"},{"type":"text","text":" "},{"text":"to form a postfix expression.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It can also contain"},{"type":"text","text":" "},{"type":"text","text":"another conditional compilation block,"},{"type":"text","text":" "},{"type":"text","text":"or a combination of these expressions and blocks."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use this syntax anywhere that you can write"},{"type":"text","text":" "},{"text":"an explicit member expression,","type":"text"},{"text":" ","type":"text"},{"text":"not just in top-level code.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In the conditional compilation block,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the branch for the "},{"code":"#if","type":"codeVoice"},{"type":"text","text":" compilation directive"},{"type":"text","text":" "},{"type":"text","text":"must contain at least one expression."},{"type":"text","text":" "},{"type":"text","text":"The other branches can be empty."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"explicit-member-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"decimal-digits","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"\n"},{"inlineContent":[{"type":"text","text":"explicit-member-expression"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"generic-argument-clause"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"text":"explicit-member-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"postfix-expression","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":"(","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-names"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"},{"type":"text","text":" "},{"text":"\n","type":"text"},{"inlineContent":[{"type":"text","text":"explicit-member-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conditional-compilation-block","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"argument-names","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-name"}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"argument-names","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"text","text":"\n"},{"inlineContent":[{"text":"argument-name","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":":","type":"codeVoice"}]}]}],"name":"Grammar of an explicit member expression"},{"level":3,"type":"heading","text":"Postfix Self Expression","anchor":"Postfix-Self-Expression"},{"type":"paragraph","inlineContent":[{"text":"A postfix ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" expression consists of an expression or the name of a type,"},{"type":"text","text":" "},{"type":"text","text":"immediately followed by "},{"code":".self","type":"codeVoice"},{"text":". It has the following forms:","type":"text"}]},{"code":["<#expression#>.self","<#type#>.self"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first form evaluates to the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"For example, ","type":"text"},{"code":"x.self","type":"codeVoice"},{"text":" evaluates to ","type":"text"},{"code":"x","type":"codeVoice"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"The second form evaluates to the value of the "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":". Use this form"},{"type":"text","text":" "},{"text":"to access a type as a value. For example,","type":"text"},{"text":" ","type":"text"},{"text":"because ","type":"text"},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" evaluates to the "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" type itself,"},{"text":" ","type":"text"},{"text":"you can pass it to a function or method that accepts a type-level argument.","type":"text"}],"type":"paragraph"},{"style":"note","type":"aside","name":"Grammar of a postfix self expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"postfix-self-expression","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"inlineContent":[{"code":"self","type":"codeVoice"}],"type":"strong"}],"type":"paragraph"}]},{"text":"Subscript Expression","anchor":"Subscript-Expression","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscript expression"}]},{"type":"text","text":" provides subscript access"},{"text":" ","type":"text"},{"text":"using the getter and setter","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of the corresponding subscript declaration."},{"text":" ","type":"text"},{"text":"It has the following form:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["<#expression#>[<#index expressions#>]"]},{"type":"paragraph","inlineContent":[{"text":"To evaluate the value of a subscript expression,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the subscript getter for the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]},{"type":"text","text":"’s type is called"},{"text":" ","type":"text"},{"text":"with the ","type":"text"},{"inlineContent":[{"type":"text","text":"index expressions"}],"type":"emphasis"},{"type":"text","text":" passed as the subscript parameters."},{"text":" ","type":"text"},{"type":"text","text":"To set its value,"},{"type":"text","text":" "},{"type":"text","text":"the subscript setter is called in the same way."}]},{"inlineContent":[{"type":"text","text":"For information about subscript declarations,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"name":"Grammar of a subscript expression","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"subscript-expression","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"postfix-expression"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"["}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-call-argument-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}]}],"type":"aside","style":"note"},{"level":3,"text":"Forced-Value Expression","type":"heading","anchor":"Forced-Value-Expression"},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"forced-value expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" unwraps an optional value"},{"type":"text","text":" "},{"type":"text","text":"that you are certain isn’t "},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It has the following form:"}],"type":"paragraph"},{"syntax":"swift","code":["<#expression#>!"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If the value of the "},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the optional value is unwrapped"},{"text":" ","type":"text"},{"text":"and returned with the corresponding non-optional type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Otherwise, a runtime error is raised."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The unwrapped value of a forced-value expression can be modified,"},{"text":" ","type":"text"},{"type":"text","text":"either by mutating the value itself,"},{"type":"text","text":" "},{"text":"or by assigning to one of the value’s members.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"syntax":"swift","type":"codeListing","code":["var x: Int? = 0","x! += 1","\/\/ x is now 1","","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","someDictionary[\"a\"]![0] = 100","\/\/ someDictionary is now [\"a\": [100, 2, 3], \"b\": [10, 20]]"]},{"name":"Grammar of a forced-value expression","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"forced-value-expression"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix-expression"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"!"}],"type":"strong"}]}]},{"type":"heading","anchor":"Optional-Chaining-Expression","level":3,"text":"Optional-Chaining Expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"optional-chaining expression"}],"type":"emphasis"},{"type":"text","text":" provides a simplified syntax"},{"type":"text","text":" "},{"type":"text","text":"for using optional values in postfix expressions."},{"text":" ","type":"text"},{"type":"text","text":"It has the following form:"}]},{"syntax":"swift","type":"codeListing","code":["<#expression#>?"]},{"inlineContent":[{"type":"text","text":"The postfix "},{"type":"codeVoice","code":"?"},{"type":"text","text":" operator makes an optional-chaining expression"},{"type":"text","text":" "},{"text":"from an expression without changing the expression’s value.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Optional-chaining expressions must appear within a postfix expression,"},{"text":" ","type":"text"},{"text":"and they cause the postfix expression to be evaluated in a special way.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"all of the other operations in the postfix expression are ignored"},{"type":"text","text":" "},{"type":"text","text":"and the entire postfix expression evaluates to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"If the value of the optional-chaining expression isn’t "},{"type":"codeVoice","code":"nil"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"the value of the optional-chaining expression is unwrapped","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and used to evaluate the rest of the postfix expression."},{"text":" ","type":"text"},{"type":"text","text":"In either case,"},{"text":" ","type":"text"},{"text":"the value of the postfix expression is still of an optional type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a postfix expression that contains an optional-chaining expression"},{"text":" ","type":"text"},{"type":"text","text":"is nested inside other postfix expressions,"},{"text":" ","type":"text"},{"text":"only the outermost expression returns an optional type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"In the example below,"},{"text":" ","type":"text"},{"type":"text","text":"when "},{"type":"codeVoice","code":"c"},{"type":"text","text":" isn’t "},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"its value is unwrapped and used to evaluate "},{"type":"codeVoice","code":".property"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"the value of which is used to evaluate ","type":"text"},{"code":".performAction()","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"The entire expression ","type":"text"},{"code":"c?.property.performAction()","type":"codeVoice"},{"type":"text","text":" "},{"text":"has a value of an optional type.","type":"text"}]},{"type":"codeListing","code":["var c: SomeClass?","var result: Bool? = c?.property.performAction()"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The following example shows the behavior"},{"text":" ","type":"text"},{"text":"of the example above","type":"text"},{"type":"text","text":" "},{"text":"without using optional chaining.","type":"text"}],"type":"paragraph"},{"code":["var result: Bool?","if let unwrappedC = c {","    result = unwrappedC.property.performAction()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The unwrapped value of an optional-chaining expression can be modified,","type":"text"},{"type":"text","text":" "},{"text":"either by mutating the value itself,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or by assigning to one of the value’s members."},{"type":"text","text":" "},{"text":"If the value of the optional-chaining expression is ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the expression on the right-hand side of the assignment operator"},{"text":" ","type":"text"},{"type":"text","text":"isn’t evaluated."},{"type":"text","text":" "},{"type":"text","text":"For example:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func someFunctionWithSideEffects() -> Int {","    return 42  \/\/ No actual side effects.","}","var someDictionary = [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"not here\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects isn't evaluated","\/\/ someDictionary is still [\"a\": [1, 2, 3], \"b\": [10, 20]]","","someDictionary[\"a\"]?[0] = someFunctionWithSideEffects()","\/\/ someFunctionWithSideEffects is evaluated and returns 42","\/\/ someDictionary is now [\"a\": [42, 2, 3], \"b\": [10, 20]]"]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"optional-chaining-expression"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"postfix-expression","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"code":"?","type":"codeVoice"}],"type":"strong"}]}],"style":"note","type":"aside","name":"Grammar of an optional-chaining expression"},{"style":"note","name":"Beta Software","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Learn more about using ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/support\/beta-software\/","isActive":true},{"text":".","type":"text"}]}],"type":"aside"}]}],"metadata":{"title":"Expressions"},"schemaVersion":{"minor":3,"major":0,"patch":0},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"kind":"article","sections":[],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators":{"title":"Advanced Operators","url":"\/documentation\/the-swift-programming-language\/advancedoperators","kind":"article","role":"article","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators","abstract":[{"type":"text","text":"Define custom operators, perform bitwise operations, and use builder syntax."}]},"https://developer.apple.com/documentation/swift/dsohandle()":{"title":"dsohandle()","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()","titleInlineContent":[{"code":"dsohandle()","type":"codeVoice"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/dsohandle()"},"https://developer.apple.com/documentation/swift/column()":{"title":"column()","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/column()","titleInlineContent":[{"code":"column()","type":"codeVoice"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/column()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"title":"Basic Operators","type":"topic","role":"article","kind":"article","abstract":[{"text":"Perform operations like assignment, arithmetic, and comparison.","type":"text"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","url":"\/documentation\/the-swift-programming-language\/basicoperators"},"https://developer.apple.com/support/beta-software/":{"title":"Apple’s beta software","type":"link","identifier":"https:\/\/developer.apple.com\/support\/beta-software\/","titleInlineContent":[{"type":"text","text":"Apple’s beta software"}],"url":"https:\/\/developer.apple.com\/support\/beta-software\/"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Closure-Expressions":{"url":"\/documentation\/the-swift-programming-language\/closures#Closure-Expressions","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Closure-Expressions","kind":"section","type":"topic","abstract":[],"title":"Closure Expressions"},"https://help.apple.com/xcode/mac/current/#/dev4c60242fc":{"identifier":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc","titleInlineContent":[{"type":"text","text":"Add a color, file, or image literal"}],"title":"Add a color, file, or image literal","type":"link","url":"https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev4c60242fc"},"https://developer.apple.com/documentation/swift/filePath()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()","titleInlineContent":[{"code":"filePath()","type":"codeVoice"}],"title":"filePath()","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/filePath()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-for-Closures","kind":"section","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Resolving-Strong-Reference-Cycles-for-Closures","title":"Resolving Strong Reference Cycles for Closures","type":"topic","abstract":[]},"https://developer.apple.com/documentation/swift/file()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/file()","titleInlineContent":[{"code":"file()","type":"codeVoice"}],"title":"file()","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/file()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions#In-Out-Parameters":{"abstract":[],"title":"In-Out Parameters","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions#In-Out-Parameters","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions#In-Out-Parameters","kind":"section"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Escaping-Closures":{"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Escaping-Closures","title":"Escaping Closures","url":"\/documentation\/the-swift-programming-language\/closures#Escaping-Closures","kind":"section","abstract":[]},"https://developer.apple.com/documentation/swift/line()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/line()","titleInlineContent":[{"code":"line()","type":"codeVoice"}],"title":"line()","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/line()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes":{"type":"topic","role":"article","url":"\/documentation\/the-swift-programming-language\/attributes","kind":"article","abstract":[{"type":"text","text":"Add information to declarations and types."}],"title":"Attributes","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Macros":{"kind":"article","title":"Macros","type":"topic","url":"\/documentation\/the-swift-programming-language\/macros","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Macros","role":"article","abstract":[{"type":"text","text":"Use macros to generate code at compile time."}]},"https://developer.apple.com/documentation/swift/operator_declarations":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"title":"Operator Declarations","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Implicit-Conversion-to-a-Pointer-Type":{"url":"\/documentation\/the-swift-programming-language\/expressions#Implicit-Conversion-to-a-Pointer-Type","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Implicit-Conversion-to-a-Pointer-Type","kind":"section","type":"topic","abstract":[],"title":"Implicit Conversion to a Pointer Type"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i":{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i","titleInlineContent":[{"type":"text","text":"Key-Value Observing Programming Guide"}],"title":"Key-Value Observing Programming Guide","type":"link","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i"},"https://developer.apple.com/documentation/swift/fileID()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()","titleInlineContent":[{"code":"fileID()","type":"codeVoice"}],"title":"fileID()","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/fileID()"},"https://developer.apple.com/documentation/swift/function()":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/function()","titleInlineContent":[{"code":"function()","type":"codeVoice"}],"title":"function()","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/function()"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Methods-with-Special-Names":{"url":"\/documentation\/the-swift-programming-language\/declarations#Methods-with-Special-Names","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Methods-with-Special-Names","kind":"section","type":"topic","abstract":[],"title":"Methods with Special Names"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Protocol-Subscript-Declaration":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Protocol-Subscript-Declaration","kind":"section","url":"\/documentation\/the-swift-programming-language\/declarations#Protocol-Subscript-Declaration","title":"Protocol Subscript Declaration","type":"topic","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"title":"The Swift Programming Language (6.0 beta)","abstract":[],"type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","url":"\/documentation\/the-swift-programming-language","role":"collection","kind":"article"},"https://developer.apple.com/documentation/swift/keypath":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/keypath","titleInlineContent":[{"code":"KeyPath","type":"codeVoice"}],"title":"KeyPath","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/keypath"},"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i":{"identifier":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i","titleInlineContent":[{"type":"text","text":"Key-Value Coding Programming Guide"}],"title":"Key-Value Coding Programming Guide","type":"link","url":"https:\/\/developer.apple.com\/library\/content\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators#Ternary-Conditional-Operator":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators#Ternary-Conditional-Operator","kind":"section","url":"\/documentation\/the-swift-programming-language\/basicoperators#Ternary-Conditional-Operator","title":"Ternary Conditional Operator","type":"topic","abstract":[]},"https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types","titleInlineContent":[{"type":"text","text":"Working with Foundation Types"}],"title":"Working with Foundation Types","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/imported_c_and_objective_c_apis\/working_with_foundation_types"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting":{"url":"\/documentation\/the-swift-programming-language\/typecasting","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting","abstract":[{"text":"Determine a value’s runtime type and give it more specific type information.","type":"text"}],"type":"topic","kind":"article","role":"article","title":"Type Casting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Postfix-Expressions":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Postfix-Expressions","kind":"section","url":"\/documentation\/the-swift-programming-language\/expressions#Postfix-Expressions","title":"Postfix Expressions","type":"topic","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ErrorHandling":{"type":"topic","title":"Error Handling","abstract":[{"type":"text","text":"Respond to and recover from errors."}],"role":"article","url":"\/documentation\/the-swift-programming-language\/errorhandling","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ErrorHandling","kind":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Expressions#Function-Call-Expression":{"url":"\/documentation\/the-swift-programming-language\/expressions#Function-Call-Expression","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Expressions#Function-Call-Expression","kind":"section","type":"topic","abstract":[],"title":"Function Call Expression"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Function-Declaration":{"url":"\/documentation\/the-swift-programming-language\/declarations#Function-Declaration","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Function-Declaration","kind":"section","type":"topic","abstract":[],"title":"Function Declaration"},"https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift","titleInlineContent":[{"type":"text","text":"Using Objective-C Runtime Features in Swift"}],"title":"Using Objective-C Runtime Features in Swift","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/using_objective_c_runtime_features_in_swift"}}}